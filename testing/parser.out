Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> master
Rule 1     master -> program
Rule 2     program -> function
Rule 3     program -> function program
Rule 4     program -> declaration program
Rule 5     program -> prototype program
Rule 6     prototype -> TYPE NAME LPAREN paramlist RPAREN SEMICOLON
Rule 7     prototype -> TYPE specialvar LPAREN paramlist RPAREN SEMICOLON
Rule 8     allthestars -> TIMES
Rule 9     allthestars -> TIMES allthestars
Rule 10    function -> TYPE NAME LPAREN paramlist RPAREN LBRACE fbody RBRACE
Rule 11    function -> TYPE specialvar LPAREN paramlist RPAREN LBRACE fbody RBRACE
Rule 12    paramlist -> <empty>
Rule 13    paramlist -> TYPE NAME paramlist2
Rule 14    paramlist -> TYPE specialvar paramlist2
Rule 15    paramlist2 -> <empty>
Rule 16    paramlist2 -> COMMA TYPE NAME paramlist2
Rule 17    paramlist2 -> COMMA TYPE specialvar paramlist2
Rule 18    fbody -> allstatement fbody
Rule 19    fbody -> <empty>
Rule 20    allstatement -> statement
Rule 21    allstatement -> unmatchedstatement
Rule 22    statement -> assignment
Rule 23    statement -> declaration
Rule 24    statement -> whileblock
Rule 25    statement -> ifblock
Rule 26    statement -> returnstatement
Rule 27    statement -> functioncall SEMICOLON
Rule 28    returnstatement -> RETURN expression SEMICOLON
Rule 29    returnstatement -> RETURN SEMICOLON
Rule 30    functioncall -> NAME LPAREN arguments RPAREN
Rule 31    arguments -> expression
Rule 32    arguments -> expression COMMA arguments
Rule 33    statement -> SEMICOLON
Rule 34    unmatchedstatement -> IF LPAREN conditional RPAREN allstatement
Rule 35    unmatchedstatement -> IF LPAREN conditional RPAREN statement ELSE unmatchedstatement
Rule 36    unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE unmatchedstatement
Rule 37    unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE
Rule 38    ifblock -> IF LPAREN conditional RPAREN statement ELSE statement
Rule 39    ifblock -> IF LPAREN conditional RPAREN statement ELSE LBRACE fbody RBRACE
Rule 40    ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE
Rule 41    ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE statement
Rule 42    whileblock -> WHILE LPAREN conditional RPAREN LBRACE fbody RBRACE
Rule 43    conditional -> LPAREN conditional RPAREN
Rule 44    conditional -> conditionbase
Rule 45    conditional -> NOT LPAREN conditional RPAREN
Rule 46    conditional -> conditional LESSTHANEQ conditional
Rule 47    conditional -> conditional GREATERTHANEQ conditional
Rule 48    conditional -> conditional UNEQUAL conditional
Rule 49    conditional -> conditional EQUALCHECK conditional
Rule 50    conditional -> conditional LESSTHAN conditional
Rule 51    conditional -> conditional GREATERTHAN conditional
Rule 52    conditional -> conditional ANDOPERATOR conditional
Rule 53    conditional -> conditional OROPERATOR conditional
Rule 54    conditionbase -> CS LESSTHANEQ CS
Rule 55    conditionbase -> CS GREATERTHANEQ CS
Rule 56    conditionbase -> CS UNEQUAL CS
Rule 57    conditionbase -> CS EQUALCHECK CS
Rule 58    conditionbase -> CS LESSTHAN CS
Rule 59    conditionbase -> CS GREATERTHAN CS
Rule 60    CS -> expression
Rule 61    CS -> NOT LPAREN expression RPAREN
Rule 62    declaration -> TYPE dlist1 SEMICOLON
Rule 63    dlist1 -> NAME
Rule 64    dlist1 -> NAME COMMA dlist1
Rule 65    dlist1 -> specialvar
Rule 66    dlist1 -> specialvar COMMA dlist1
Rule 67    specialvar -> TIMES specialvar
Rule 68    specialvar -> TIMES NAME
Rule 69    assignment -> assignment_base SEMICOLON
Rule 70    assignment_base -> TIMES pointervar EQUALS expression
Rule 71    assignment_base -> NAME EQUALS expression
Rule 72    expression -> functioncall
Rule 73    expression -> expression PLUS expression
Rule 74    expression -> expression MINUS expression
Rule 75    expression -> expression DIVIDE expression
Rule 76    expression -> expression TIMES expression
Rule 77    expression -> MINUS expression
Rule 78    expression -> LPAREN expression RPAREN
Rule 79    expression -> allnumbers
Rule 80    allnumbers -> FLOAT
Rule 81    allnumbers -> NUMBER
Rule 82    expression -> pointervar
Rule 83    pointervar -> TIMES pointervar
Rule 84    pointervar -> ADDROF pointervar
Rule 85    pointervar -> NAME

Terminals, with rules where they appear

ADDROF               : 84
ANDOPERATOR          : 52
COMMA                : 16 17 32 64 66
DIVIDE               : 75
ELSE                 : 35 36 38 39 40 41
EQUALCHECK           : 49 57
EQUALS               : 70 71
FLOAT                : 80
GREATERTHAN          : 51 59
GREATERTHANEQ        : 47 55
IF                   : 34 35 36 37 38 39 40 41
LBRACE               : 10 11 36 37 39 40 40 41 42
LESSTHAN             : 50 58
LESSTHANEQ           : 46 54
LPAREN               : 6 7 10 11 30 34 35 36 37 38 39 40 41 42 43 45 61 78
MINUS                : 74 77
NAME                 : 6 10 13 16 30 63 64 68 71 85
NOT                  : 45 61
NUMBER               : 81
OROPERATOR           : 53
PLUS                 : 73
RBRACE               : 10 11 36 37 39 40 40 41 42
RETURN               : 28 29
RPAREN               : 6 7 10 11 30 34 35 36 37 38 39 40 41 42 43 45 61 78
SEMICOLON            : 6 7 27 28 29 33 62 69
TIMES                : 8 9 67 68 70 76 83
TYPE                 : 6 7 10 11 13 14 16 17 62
UNEQUAL              : 48 56
WHILE                : 42
error                : 

Nonterminals, with rules where they appear

CS                   : 54 54 55 55 56 56 57 57 58 58 59 59
allnumbers           : 79
allstatement         : 18 34
allthestars          : 9
arguments            : 30 32
assignment           : 22
assignment_base      : 69
conditional          : 34 35 36 37 38 39 40 41 42 43 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53
conditionbase        : 44
declaration          : 4 23
dlist1               : 62 64 66
expression           : 28 31 32 60 61 70 71 73 73 74 74 75 75 76 76 77 78
fbody                : 10 11 18 36 37 39 40 40 41 42
function             : 2 3
functioncall         : 27 72
ifblock              : 25
master               : 0
paramlist            : 6 7 10 11
paramlist2           : 13 14 16 17
pointervar           : 70 82 83 84
program              : 1 3 4 5
prototype            : 5
returnstatement      : 26
specialvar           : 7 11 14 17 65 66 67
statement            : 20 35 38 38 39 41
unmatchedstatement   : 21 35 36
whileblock           : 24

Parsing method: LALR

state 0

    (0) S' -> . master
    (1) master -> . program
    (2) program -> . function
    (3) program -> . function program
    (4) program -> . declaration program
    (5) program -> . prototype program
    (10) function -> . TYPE NAME LPAREN paramlist RPAREN LBRACE fbody RBRACE
    (11) function -> . TYPE specialvar LPAREN paramlist RPAREN LBRACE fbody RBRACE
    (62) declaration -> . TYPE dlist1 SEMICOLON
    (6) prototype -> . TYPE NAME LPAREN paramlist RPAREN SEMICOLON
    (7) prototype -> . TYPE specialvar LPAREN paramlist RPAREN SEMICOLON

    TYPE            shift and go to state 6

    function                       shift and go to state 1
    program                        shift and go to state 2
    master                         shift and go to state 3
    declaration                    shift and go to state 4
    prototype                      shift and go to state 5

state 1

    (2) program -> function .
    (3) program -> function . program
    (2) program -> . function
    (3) program -> . function program
    (4) program -> . declaration program
    (5) program -> . prototype program
    (10) function -> . TYPE NAME LPAREN paramlist RPAREN LBRACE fbody RBRACE
    (11) function -> . TYPE specialvar LPAREN paramlist RPAREN LBRACE fbody RBRACE
    (62) declaration -> . TYPE dlist1 SEMICOLON
    (6) prototype -> . TYPE NAME LPAREN paramlist RPAREN SEMICOLON
    (7) prototype -> . TYPE specialvar LPAREN paramlist RPAREN SEMICOLON

    $end            reduce using rule 2 (program -> function .)
    TYPE            shift and go to state 6

    function                       shift and go to state 1
    declaration                    shift and go to state 4
    program                        shift and go to state 7
    prototype                      shift and go to state 5

state 2

    (1) master -> program .

    $end            reduce using rule 1 (master -> program .)


state 3

    (0) S' -> master .



state 4

    (4) program -> declaration . program
    (2) program -> . function
    (3) program -> . function program
    (4) program -> . declaration program
    (5) program -> . prototype program
    (10) function -> . TYPE NAME LPAREN paramlist RPAREN LBRACE fbody RBRACE
    (11) function -> . TYPE specialvar LPAREN paramlist RPAREN LBRACE fbody RBRACE
    (62) declaration -> . TYPE dlist1 SEMICOLON
    (6) prototype -> . TYPE NAME LPAREN paramlist RPAREN SEMICOLON
    (7) prototype -> . TYPE specialvar LPAREN paramlist RPAREN SEMICOLON

    TYPE            shift and go to state 6

    function                       shift and go to state 1
    declaration                    shift and go to state 4
    program                        shift and go to state 8
    prototype                      shift and go to state 5

state 5

    (5) program -> prototype . program
    (2) program -> . function
    (3) program -> . function program
    (4) program -> . declaration program
    (5) program -> . prototype program
    (10) function -> . TYPE NAME LPAREN paramlist RPAREN LBRACE fbody RBRACE
    (11) function -> . TYPE specialvar LPAREN paramlist RPAREN LBRACE fbody RBRACE
    (62) declaration -> . TYPE dlist1 SEMICOLON
    (6) prototype -> . TYPE NAME LPAREN paramlist RPAREN SEMICOLON
    (7) prototype -> . TYPE specialvar LPAREN paramlist RPAREN SEMICOLON

    TYPE            shift and go to state 6

    function                       shift and go to state 1
    declaration                    shift and go to state 4
    program                        shift and go to state 9
    prototype                      shift and go to state 5

state 6

    (10) function -> TYPE . NAME LPAREN paramlist RPAREN LBRACE fbody RBRACE
    (11) function -> TYPE . specialvar LPAREN paramlist RPAREN LBRACE fbody RBRACE
    (62) declaration -> TYPE . dlist1 SEMICOLON
    (6) prototype -> TYPE . NAME LPAREN paramlist RPAREN SEMICOLON
    (7) prototype -> TYPE . specialvar LPAREN paramlist RPAREN SEMICOLON
    (67) specialvar -> . TIMES specialvar
    (68) specialvar -> . TIMES NAME
    (63) dlist1 -> . NAME
    (64) dlist1 -> . NAME COMMA dlist1
    (65) dlist1 -> . specialvar
    (66) dlist1 -> . specialvar COMMA dlist1

    NAME            shift and go to state 10
    TIMES           shift and go to state 11

    specialvar                     shift and go to state 13
    dlist1                         shift and go to state 12

state 7

    (3) program -> function program .

    $end            reduce using rule 3 (program -> function program .)


state 8

    (4) program -> declaration program .

    $end            reduce using rule 4 (program -> declaration program .)


state 9

    (5) program -> prototype program .

    $end            reduce using rule 5 (program -> prototype program .)


state 10

    (10) function -> TYPE NAME . LPAREN paramlist RPAREN LBRACE fbody RBRACE
    (6) prototype -> TYPE NAME . LPAREN paramlist RPAREN SEMICOLON
    (63) dlist1 -> NAME .
    (64) dlist1 -> NAME . COMMA dlist1

    LPAREN          shift and go to state 15
    SEMICOLON       reduce using rule 63 (dlist1 -> NAME .)
    COMMA           shift and go to state 14


state 11

    (67) specialvar -> TIMES . specialvar
    (68) specialvar -> TIMES . NAME
    (67) specialvar -> . TIMES specialvar
    (68) specialvar -> . TIMES NAME

    NAME            shift and go to state 17
    TIMES           shift and go to state 11

    specialvar                     shift and go to state 16

state 12

    (62) declaration -> TYPE dlist1 . SEMICOLON

    SEMICOLON       shift and go to state 18


state 13

    (11) function -> TYPE specialvar . LPAREN paramlist RPAREN LBRACE fbody RBRACE
    (7) prototype -> TYPE specialvar . LPAREN paramlist RPAREN SEMICOLON
    (65) dlist1 -> specialvar .
    (66) dlist1 -> specialvar . COMMA dlist1

    LPAREN          shift and go to state 19
    SEMICOLON       reduce using rule 65 (dlist1 -> specialvar .)
    COMMA           shift and go to state 20


state 14

    (64) dlist1 -> NAME COMMA . dlist1
    (63) dlist1 -> . NAME
    (64) dlist1 -> . NAME COMMA dlist1
    (65) dlist1 -> . specialvar
    (66) dlist1 -> . specialvar COMMA dlist1
    (67) specialvar -> . TIMES specialvar
    (68) specialvar -> . TIMES NAME

    NAME            shift and go to state 23
    TIMES           shift and go to state 11

    specialvar                     shift and go to state 21
    dlist1                         shift and go to state 22

state 15

    (10) function -> TYPE NAME LPAREN . paramlist RPAREN LBRACE fbody RBRACE
    (6) prototype -> TYPE NAME LPAREN . paramlist RPAREN SEMICOLON
    (12) paramlist -> .
    (13) paramlist -> . TYPE NAME paramlist2
    (14) paramlist -> . TYPE specialvar paramlist2

    RPAREN          reduce using rule 12 (paramlist -> .)
    TYPE            shift and go to state 25

    paramlist                      shift and go to state 24

state 16

    (67) specialvar -> TIMES specialvar .

    COMMA           reduce using rule 67 (specialvar -> TIMES specialvar .)
    RPAREN          reduce using rule 67 (specialvar -> TIMES specialvar .)
    SEMICOLON       reduce using rule 67 (specialvar -> TIMES specialvar .)
    LPAREN          reduce using rule 67 (specialvar -> TIMES specialvar .)


state 17

    (68) specialvar -> TIMES NAME .

    COMMA           reduce using rule 68 (specialvar -> TIMES NAME .)
    RPAREN          reduce using rule 68 (specialvar -> TIMES NAME .)
    SEMICOLON       reduce using rule 68 (specialvar -> TIMES NAME .)
    LPAREN          reduce using rule 68 (specialvar -> TIMES NAME .)


state 18

    (62) declaration -> TYPE dlist1 SEMICOLON .

    SEMICOLON       reduce using rule 62 (declaration -> TYPE dlist1 SEMICOLON .)
    IF              reduce using rule 62 (declaration -> TYPE dlist1 SEMICOLON .)
    TYPE            reduce using rule 62 (declaration -> TYPE dlist1 SEMICOLON .)
    WHILE           reduce using rule 62 (declaration -> TYPE dlist1 SEMICOLON .)
    RETURN          reduce using rule 62 (declaration -> TYPE dlist1 SEMICOLON .)
    NAME            reduce using rule 62 (declaration -> TYPE dlist1 SEMICOLON .)
    TIMES           reduce using rule 62 (declaration -> TYPE dlist1 SEMICOLON .)
    RBRACE          reduce using rule 62 (declaration -> TYPE dlist1 SEMICOLON .)
    ELSE            reduce using rule 62 (declaration -> TYPE dlist1 SEMICOLON .)


state 19

    (11) function -> TYPE specialvar LPAREN . paramlist RPAREN LBRACE fbody RBRACE
    (7) prototype -> TYPE specialvar LPAREN . paramlist RPAREN SEMICOLON
    (12) paramlist -> .
    (13) paramlist -> . TYPE NAME paramlist2
    (14) paramlist -> . TYPE specialvar paramlist2

    RPAREN          reduce using rule 12 (paramlist -> .)
    TYPE            shift and go to state 25

    paramlist                      shift and go to state 26

state 20

    (66) dlist1 -> specialvar COMMA . dlist1
    (63) dlist1 -> . NAME
    (64) dlist1 -> . NAME COMMA dlist1
    (65) dlist1 -> . specialvar
    (66) dlist1 -> . specialvar COMMA dlist1
    (67) specialvar -> . TIMES specialvar
    (68) specialvar -> . TIMES NAME

    NAME            shift and go to state 23
    TIMES           shift and go to state 11

    specialvar                     shift and go to state 21
    dlist1                         shift and go to state 27

state 21

    (65) dlist1 -> specialvar .
    (66) dlist1 -> specialvar . COMMA dlist1

    SEMICOLON       reduce using rule 65 (dlist1 -> specialvar .)
    COMMA           shift and go to state 20


state 22

    (64) dlist1 -> NAME COMMA dlist1 .

    SEMICOLON       reduce using rule 64 (dlist1 -> NAME COMMA dlist1 .)


state 23

    (63) dlist1 -> NAME .
    (64) dlist1 -> NAME . COMMA dlist1

    SEMICOLON       reduce using rule 63 (dlist1 -> NAME .)
    COMMA           shift and go to state 14


state 24

    (10) function -> TYPE NAME LPAREN paramlist . RPAREN LBRACE fbody RBRACE
    (6) prototype -> TYPE NAME LPAREN paramlist . RPAREN SEMICOLON

    RPAREN          shift and go to state 28


state 25

    (13) paramlist -> TYPE . NAME paramlist2
    (14) paramlist -> TYPE . specialvar paramlist2
    (67) specialvar -> . TIMES specialvar
    (68) specialvar -> . TIMES NAME

    NAME            shift and go to state 30
    TIMES           shift and go to state 11

    specialvar                     shift and go to state 29

state 26

    (11) function -> TYPE specialvar LPAREN paramlist . RPAREN LBRACE fbody RBRACE
    (7) prototype -> TYPE specialvar LPAREN paramlist . RPAREN SEMICOLON

    RPAREN          shift and go to state 31


state 27

    (66) dlist1 -> specialvar COMMA dlist1 .

    SEMICOLON       reduce using rule 66 (dlist1 -> specialvar COMMA dlist1 .)


state 28

    (10) function -> TYPE NAME LPAREN paramlist RPAREN . LBRACE fbody RBRACE
    (6) prototype -> TYPE NAME LPAREN paramlist RPAREN . SEMICOLON

    LBRACE          shift and go to state 32
    SEMICOLON       shift and go to state 33


state 29

    (14) paramlist -> TYPE specialvar . paramlist2
    (15) paramlist2 -> .
    (16) paramlist2 -> . COMMA TYPE NAME paramlist2
    (17) paramlist2 -> . COMMA TYPE specialvar paramlist2

    RPAREN          reduce using rule 15 (paramlist2 -> .)
    COMMA           shift and go to state 34

    paramlist2                     shift and go to state 35

state 30

    (13) paramlist -> TYPE NAME . paramlist2
    (15) paramlist2 -> .
    (16) paramlist2 -> . COMMA TYPE NAME paramlist2
    (17) paramlist2 -> . COMMA TYPE specialvar paramlist2

    RPAREN          reduce using rule 15 (paramlist2 -> .)
    COMMA           shift and go to state 34

    paramlist2                     shift and go to state 36

state 31

    (11) function -> TYPE specialvar LPAREN paramlist RPAREN . LBRACE fbody RBRACE
    (7) prototype -> TYPE specialvar LPAREN paramlist RPAREN . SEMICOLON

    LBRACE          shift and go to state 37
    SEMICOLON       shift and go to state 38


state 32

    (10) function -> TYPE NAME LPAREN paramlist RPAREN LBRACE . fbody RBRACE
    (18) fbody -> . allstatement fbody
    (19) fbody -> .
    (20) allstatement -> . statement
    (21) allstatement -> . unmatchedstatement
    (22) statement -> . assignment
    (23) statement -> . declaration
    (24) statement -> . whileblock
    (25) statement -> . ifblock
    (26) statement -> . returnstatement
    (27) statement -> . functioncall SEMICOLON
    (33) statement -> . SEMICOLON
    (34) unmatchedstatement -> . IF LPAREN conditional RPAREN allstatement
    (35) unmatchedstatement -> . IF LPAREN conditional RPAREN statement ELSE unmatchedstatement
    (36) unmatchedstatement -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE unmatchedstatement
    (37) unmatchedstatement -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE
    (69) assignment -> . assignment_base SEMICOLON
    (62) declaration -> . TYPE dlist1 SEMICOLON
    (42) whileblock -> . WHILE LPAREN conditional RPAREN LBRACE fbody RBRACE
    (38) ifblock -> . IF LPAREN conditional RPAREN statement ELSE statement
    (39) ifblock -> . IF LPAREN conditional RPAREN statement ELSE LBRACE fbody RBRACE
    (40) ifblock -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE
    (41) ifblock -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE statement
    (28) returnstatement -> . RETURN expression SEMICOLON
    (29) returnstatement -> . RETURN SEMICOLON
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (70) assignment_base -> . TIMES pointervar EQUALS expression
    (71) assignment_base -> . NAME EQUALS expression

    RBRACE          reduce using rule 19 (fbody -> .)
    SEMICOLON       shift and go to state 42
    IF              shift and go to state 52
    TYPE            shift and go to state 56
    WHILE           shift and go to state 40
    RETURN          shift and go to state 39
    NAME            shift and go to state 53
    TIMES           shift and go to state 50

    unmatchedstatement             shift and go to state 41
    assignment                     shift and go to state 48
    declaration                    shift and go to state 49
    whileblock                     shift and go to state 43
    ifblock                        shift and go to state 44
    allstatement                   shift and go to state 54
    statement                      shift and go to state 45
    fbody                          shift and go to state 51
    functioncall                   shift and go to state 46
    returnstatement                shift and go to state 55
    assignment_base                shift and go to state 47

state 33

    (6) prototype -> TYPE NAME LPAREN paramlist RPAREN SEMICOLON .

    TYPE            reduce using rule 6 (prototype -> TYPE NAME LPAREN paramlist RPAREN SEMICOLON .)


state 34

    (16) paramlist2 -> COMMA . TYPE NAME paramlist2
    (17) paramlist2 -> COMMA . TYPE specialvar paramlist2

    TYPE            shift and go to state 57


state 35

    (14) paramlist -> TYPE specialvar paramlist2 .

    RPAREN          reduce using rule 14 (paramlist -> TYPE specialvar paramlist2 .)


state 36

    (13) paramlist -> TYPE NAME paramlist2 .

    RPAREN          reduce using rule 13 (paramlist -> TYPE NAME paramlist2 .)


state 37

    (11) function -> TYPE specialvar LPAREN paramlist RPAREN LBRACE . fbody RBRACE
    (18) fbody -> . allstatement fbody
    (19) fbody -> .
    (20) allstatement -> . statement
    (21) allstatement -> . unmatchedstatement
    (22) statement -> . assignment
    (23) statement -> . declaration
    (24) statement -> . whileblock
    (25) statement -> . ifblock
    (26) statement -> . returnstatement
    (27) statement -> . functioncall SEMICOLON
    (33) statement -> . SEMICOLON
    (34) unmatchedstatement -> . IF LPAREN conditional RPAREN allstatement
    (35) unmatchedstatement -> . IF LPAREN conditional RPAREN statement ELSE unmatchedstatement
    (36) unmatchedstatement -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE unmatchedstatement
    (37) unmatchedstatement -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE
    (69) assignment -> . assignment_base SEMICOLON
    (62) declaration -> . TYPE dlist1 SEMICOLON
    (42) whileblock -> . WHILE LPAREN conditional RPAREN LBRACE fbody RBRACE
    (38) ifblock -> . IF LPAREN conditional RPAREN statement ELSE statement
    (39) ifblock -> . IF LPAREN conditional RPAREN statement ELSE LBRACE fbody RBRACE
    (40) ifblock -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE
    (41) ifblock -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE statement
    (28) returnstatement -> . RETURN expression SEMICOLON
    (29) returnstatement -> . RETURN SEMICOLON
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (70) assignment_base -> . TIMES pointervar EQUALS expression
    (71) assignment_base -> . NAME EQUALS expression

    RBRACE          reduce using rule 19 (fbody -> .)
    SEMICOLON       shift and go to state 42
    IF              shift and go to state 52
    TYPE            shift and go to state 56
    WHILE           shift and go to state 40
    RETURN          shift and go to state 39
    NAME            shift and go to state 53
    TIMES           shift and go to state 50

    unmatchedstatement             shift and go to state 41
    assignment_base                shift and go to state 47
    assignment                     shift and go to state 48
    declaration                    shift and go to state 49
    whileblock                     shift and go to state 43
    ifblock                        shift and go to state 44
    allstatement                   shift and go to state 54
    statement                      shift and go to state 45
    fbody                          shift and go to state 58
    functioncall                   shift and go to state 46
    returnstatement                shift and go to state 55

state 38

    (7) prototype -> TYPE specialvar LPAREN paramlist RPAREN SEMICOLON .

    TYPE            reduce using rule 7 (prototype -> TYPE specialvar LPAREN paramlist RPAREN SEMICOLON .)


state 39

    (28) returnstatement -> RETURN . expression SEMICOLON
    (29) returnstatement -> RETURN . SEMICOLON
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    SEMICOLON       shift and go to state 60
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 68
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    functioncall                   shift and go to state 67
    pointervar                     shift and go to state 64
    allnumbers                     shift and go to state 63
    expression                     shift and go to state 69

state 40

    (42) whileblock -> WHILE . LPAREN conditional RPAREN LBRACE fbody RBRACE

    LPAREN          shift and go to state 71


state 41

    (21) allstatement -> unmatchedstatement .

    SEMICOLON       reduce using rule 21 (allstatement -> unmatchedstatement .)
    IF              reduce using rule 21 (allstatement -> unmatchedstatement .)
    TYPE            reduce using rule 21 (allstatement -> unmatchedstatement .)
    WHILE           reduce using rule 21 (allstatement -> unmatchedstatement .)
    RETURN          reduce using rule 21 (allstatement -> unmatchedstatement .)
    NAME            reduce using rule 21 (allstatement -> unmatchedstatement .)
    TIMES           reduce using rule 21 (allstatement -> unmatchedstatement .)
    RBRACE          reduce using rule 21 (allstatement -> unmatchedstatement .)


state 42

    (33) statement -> SEMICOLON .

    SEMICOLON       reduce using rule 33 (statement -> SEMICOLON .)
    IF              reduce using rule 33 (statement -> SEMICOLON .)
    TYPE            reduce using rule 33 (statement -> SEMICOLON .)
    WHILE           reduce using rule 33 (statement -> SEMICOLON .)
    RETURN          reduce using rule 33 (statement -> SEMICOLON .)
    NAME            reduce using rule 33 (statement -> SEMICOLON .)
    TIMES           reduce using rule 33 (statement -> SEMICOLON .)
    RBRACE          reduce using rule 33 (statement -> SEMICOLON .)
    ELSE            reduce using rule 33 (statement -> SEMICOLON .)


state 43

    (24) statement -> whileblock .

    SEMICOLON       reduce using rule 24 (statement -> whileblock .)
    IF              reduce using rule 24 (statement -> whileblock .)
    TYPE            reduce using rule 24 (statement -> whileblock .)
    WHILE           reduce using rule 24 (statement -> whileblock .)
    RETURN          reduce using rule 24 (statement -> whileblock .)
    NAME            reduce using rule 24 (statement -> whileblock .)
    TIMES           reduce using rule 24 (statement -> whileblock .)
    RBRACE          reduce using rule 24 (statement -> whileblock .)
    ELSE            reduce using rule 24 (statement -> whileblock .)


state 44

    (25) statement -> ifblock .

    SEMICOLON       reduce using rule 25 (statement -> ifblock .)
    IF              reduce using rule 25 (statement -> ifblock .)
    TYPE            reduce using rule 25 (statement -> ifblock .)
    WHILE           reduce using rule 25 (statement -> ifblock .)
    RETURN          reduce using rule 25 (statement -> ifblock .)
    NAME            reduce using rule 25 (statement -> ifblock .)
    TIMES           reduce using rule 25 (statement -> ifblock .)
    RBRACE          reduce using rule 25 (statement -> ifblock .)
    ELSE            reduce using rule 25 (statement -> ifblock .)


state 45

    (20) allstatement -> statement .

    SEMICOLON       reduce using rule 20 (allstatement -> statement .)
    IF              reduce using rule 20 (allstatement -> statement .)
    TYPE            reduce using rule 20 (allstatement -> statement .)
    WHILE           reduce using rule 20 (allstatement -> statement .)
    RETURN          reduce using rule 20 (allstatement -> statement .)
    NAME            reduce using rule 20 (allstatement -> statement .)
    TIMES           reduce using rule 20 (allstatement -> statement .)
    RBRACE          reduce using rule 20 (allstatement -> statement .)


state 46

    (27) statement -> functioncall . SEMICOLON

    SEMICOLON       shift and go to state 72


state 47

    (69) assignment -> assignment_base . SEMICOLON

    SEMICOLON       shift and go to state 73


state 48

    (22) statement -> assignment .

    SEMICOLON       reduce using rule 22 (statement -> assignment .)
    IF              reduce using rule 22 (statement -> assignment .)
    TYPE            reduce using rule 22 (statement -> assignment .)
    WHILE           reduce using rule 22 (statement -> assignment .)
    RETURN          reduce using rule 22 (statement -> assignment .)
    NAME            reduce using rule 22 (statement -> assignment .)
    TIMES           reduce using rule 22 (statement -> assignment .)
    RBRACE          reduce using rule 22 (statement -> assignment .)
    ELSE            reduce using rule 22 (statement -> assignment .)


state 49

    (23) statement -> declaration .

    SEMICOLON       reduce using rule 23 (statement -> declaration .)
    IF              reduce using rule 23 (statement -> declaration .)
    TYPE            reduce using rule 23 (statement -> declaration .)
    WHILE           reduce using rule 23 (statement -> declaration .)
    RETURN          reduce using rule 23 (statement -> declaration .)
    NAME            reduce using rule 23 (statement -> declaration .)
    TIMES           reduce using rule 23 (statement -> declaration .)
    RBRACE          reduce using rule 23 (statement -> declaration .)
    ELSE            reduce using rule 23 (statement -> declaration .)


state 50

    (70) assignment_base -> TIMES . pointervar EQUALS expression
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62
    NAME            shift and go to state 74

    pointervar                     shift and go to state 75

state 51

    (10) function -> TYPE NAME LPAREN paramlist RPAREN LBRACE fbody . RBRACE

    RBRACE          shift and go to state 76


state 52

    (34) unmatchedstatement -> IF . LPAREN conditional RPAREN allstatement
    (35) unmatchedstatement -> IF . LPAREN conditional RPAREN statement ELSE unmatchedstatement
    (36) unmatchedstatement -> IF . LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE unmatchedstatement
    (37) unmatchedstatement -> IF . LPAREN conditional RPAREN LBRACE fbody RBRACE
    (38) ifblock -> IF . LPAREN conditional RPAREN statement ELSE statement
    (39) ifblock -> IF . LPAREN conditional RPAREN statement ELSE LBRACE fbody RBRACE
    (40) ifblock -> IF . LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE
    (41) ifblock -> IF . LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE statement

    LPAREN          shift and go to state 77


state 53

    (30) functioncall -> NAME . LPAREN arguments RPAREN
    (71) assignment_base -> NAME . EQUALS expression

    LPAREN          shift and go to state 79
    EQUALS          shift and go to state 78


state 54

    (18) fbody -> allstatement . fbody
    (18) fbody -> . allstatement fbody
    (19) fbody -> .
    (20) allstatement -> . statement
    (21) allstatement -> . unmatchedstatement
    (22) statement -> . assignment
    (23) statement -> . declaration
    (24) statement -> . whileblock
    (25) statement -> . ifblock
    (26) statement -> . returnstatement
    (27) statement -> . functioncall SEMICOLON
    (33) statement -> . SEMICOLON
    (34) unmatchedstatement -> . IF LPAREN conditional RPAREN allstatement
    (35) unmatchedstatement -> . IF LPAREN conditional RPAREN statement ELSE unmatchedstatement
    (36) unmatchedstatement -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE unmatchedstatement
    (37) unmatchedstatement -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE
    (69) assignment -> . assignment_base SEMICOLON
    (62) declaration -> . TYPE dlist1 SEMICOLON
    (42) whileblock -> . WHILE LPAREN conditional RPAREN LBRACE fbody RBRACE
    (38) ifblock -> . IF LPAREN conditional RPAREN statement ELSE statement
    (39) ifblock -> . IF LPAREN conditional RPAREN statement ELSE LBRACE fbody RBRACE
    (40) ifblock -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE
    (41) ifblock -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE statement
    (28) returnstatement -> . RETURN expression SEMICOLON
    (29) returnstatement -> . RETURN SEMICOLON
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (70) assignment_base -> . TIMES pointervar EQUALS expression
    (71) assignment_base -> . NAME EQUALS expression

    RBRACE          reduce using rule 19 (fbody -> .)
    SEMICOLON       shift and go to state 42
    IF              shift and go to state 52
    TYPE            shift and go to state 56
    WHILE           shift and go to state 40
    RETURN          shift and go to state 39
    NAME            shift and go to state 53
    TIMES           shift and go to state 50

    unmatchedstatement             shift and go to state 41
    assignment                     shift and go to state 48
    fbody                          shift and go to state 80
    whileblock                     shift and go to state 43
    ifblock                        shift and go to state 44
    allstatement                   shift and go to state 54
    statement                      shift and go to state 45
    declaration                    shift and go to state 49
    functioncall                   shift and go to state 46
    returnstatement                shift and go to state 55
    assignment_base                shift and go to state 47

state 55

    (26) statement -> returnstatement .

    SEMICOLON       reduce using rule 26 (statement -> returnstatement .)
    IF              reduce using rule 26 (statement -> returnstatement .)
    TYPE            reduce using rule 26 (statement -> returnstatement .)
    WHILE           reduce using rule 26 (statement -> returnstatement .)
    RETURN          reduce using rule 26 (statement -> returnstatement .)
    NAME            reduce using rule 26 (statement -> returnstatement .)
    TIMES           reduce using rule 26 (statement -> returnstatement .)
    RBRACE          reduce using rule 26 (statement -> returnstatement .)
    ELSE            reduce using rule 26 (statement -> returnstatement .)


state 56

    (62) declaration -> TYPE . dlist1 SEMICOLON
    (63) dlist1 -> . NAME
    (64) dlist1 -> . NAME COMMA dlist1
    (65) dlist1 -> . specialvar
    (66) dlist1 -> . specialvar COMMA dlist1
    (67) specialvar -> . TIMES specialvar
    (68) specialvar -> . TIMES NAME

    NAME            shift and go to state 23
    TIMES           shift and go to state 11

    specialvar                     shift and go to state 21
    dlist1                         shift and go to state 12

state 57

    (16) paramlist2 -> COMMA TYPE . NAME paramlist2
    (17) paramlist2 -> COMMA TYPE . specialvar paramlist2
    (67) specialvar -> . TIMES specialvar
    (68) specialvar -> . TIMES NAME

    NAME            shift and go to state 81
    TIMES           shift and go to state 11

    specialvar                     shift and go to state 82

state 58

    (11) function -> TYPE specialvar LPAREN paramlist RPAREN LBRACE fbody . RBRACE

    RBRACE          shift and go to state 83


state 59

    (80) allnumbers -> FLOAT .

    PLUS            reduce using rule 80 (allnumbers -> FLOAT .)
    MINUS           reduce using rule 80 (allnumbers -> FLOAT .)
    DIVIDE          reduce using rule 80 (allnumbers -> FLOAT .)
    TIMES           reduce using rule 80 (allnumbers -> FLOAT .)
    SEMICOLON       reduce using rule 80 (allnumbers -> FLOAT .)
    LESSTHANEQ      reduce using rule 80 (allnumbers -> FLOAT .)
    GREATERTHANEQ   reduce using rule 80 (allnumbers -> FLOAT .)
    UNEQUAL         reduce using rule 80 (allnumbers -> FLOAT .)
    EQUALCHECK      reduce using rule 80 (allnumbers -> FLOAT .)
    LESSTHAN        reduce using rule 80 (allnumbers -> FLOAT .)
    GREATERTHAN     reduce using rule 80 (allnumbers -> FLOAT .)
    RPAREN          reduce using rule 80 (allnumbers -> FLOAT .)
    COMMA           reduce using rule 80 (allnumbers -> FLOAT .)
    ANDOPERATOR     reduce using rule 80 (allnumbers -> FLOAT .)
    OROPERATOR      reduce using rule 80 (allnumbers -> FLOAT .)


state 60

    (29) returnstatement -> RETURN SEMICOLON .

    SEMICOLON       reduce using rule 29 (returnstatement -> RETURN SEMICOLON .)
    IF              reduce using rule 29 (returnstatement -> RETURN SEMICOLON .)
    TYPE            reduce using rule 29 (returnstatement -> RETURN SEMICOLON .)
    WHILE           reduce using rule 29 (returnstatement -> RETURN SEMICOLON .)
    RETURN          reduce using rule 29 (returnstatement -> RETURN SEMICOLON .)
    NAME            reduce using rule 29 (returnstatement -> RETURN SEMICOLON .)
    TIMES           reduce using rule 29 (returnstatement -> RETURN SEMICOLON .)
    RBRACE          reduce using rule 29 (returnstatement -> RETURN SEMICOLON .)
    ELSE            reduce using rule 29 (returnstatement -> RETURN SEMICOLON .)


state 61

    (30) functioncall -> NAME . LPAREN arguments RPAREN
    (85) pointervar -> NAME .

    LPAREN          shift and go to state 79
    PLUS            reduce using rule 85 (pointervar -> NAME .)
    MINUS           reduce using rule 85 (pointervar -> NAME .)
    DIVIDE          reduce using rule 85 (pointervar -> NAME .)
    TIMES           reduce using rule 85 (pointervar -> NAME .)
    SEMICOLON       reduce using rule 85 (pointervar -> NAME .)
    RPAREN          reduce using rule 85 (pointervar -> NAME .)
    LESSTHANEQ      reduce using rule 85 (pointervar -> NAME .)
    GREATERTHANEQ   reduce using rule 85 (pointervar -> NAME .)
    UNEQUAL         reduce using rule 85 (pointervar -> NAME .)
    EQUALCHECK      reduce using rule 85 (pointervar -> NAME .)
    LESSTHAN        reduce using rule 85 (pointervar -> NAME .)
    GREATERTHAN     reduce using rule 85 (pointervar -> NAME .)
    COMMA           reduce using rule 85 (pointervar -> NAME .)
    ANDOPERATOR     reduce using rule 85 (pointervar -> NAME .)
    OROPERATOR      reduce using rule 85 (pointervar -> NAME .)


state 62

    (84) pointervar -> ADDROF . pointervar
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62
    NAME            shift and go to state 74

    pointervar                     shift and go to state 84

state 63

    (79) expression -> allnumbers .

    PLUS            reduce using rule 79 (expression -> allnumbers .)
    MINUS           reduce using rule 79 (expression -> allnumbers .)
    DIVIDE          reduce using rule 79 (expression -> allnumbers .)
    TIMES           reduce using rule 79 (expression -> allnumbers .)
    LESSTHANEQ      reduce using rule 79 (expression -> allnumbers .)
    GREATERTHANEQ   reduce using rule 79 (expression -> allnumbers .)
    UNEQUAL         reduce using rule 79 (expression -> allnumbers .)
    EQUALCHECK      reduce using rule 79 (expression -> allnumbers .)
    LESSTHAN        reduce using rule 79 (expression -> allnumbers .)
    GREATERTHAN     reduce using rule 79 (expression -> allnumbers .)
    RPAREN          reduce using rule 79 (expression -> allnumbers .)
    SEMICOLON       reduce using rule 79 (expression -> allnumbers .)
    COMMA           reduce using rule 79 (expression -> allnumbers .)
    ANDOPERATOR     reduce using rule 79 (expression -> allnumbers .)
    OROPERATOR      reduce using rule 79 (expression -> allnumbers .)


state 64

    (82) expression -> pointervar .

    PLUS            reduce using rule 82 (expression -> pointervar .)
    MINUS           reduce using rule 82 (expression -> pointervar .)
    DIVIDE          reduce using rule 82 (expression -> pointervar .)
    TIMES           reduce using rule 82 (expression -> pointervar .)
    LESSTHANEQ      reduce using rule 82 (expression -> pointervar .)
    GREATERTHANEQ   reduce using rule 82 (expression -> pointervar .)
    UNEQUAL         reduce using rule 82 (expression -> pointervar .)
    EQUALCHECK      reduce using rule 82 (expression -> pointervar .)
    LESSTHAN        reduce using rule 82 (expression -> pointervar .)
    GREATERTHAN     reduce using rule 82 (expression -> pointervar .)
    RPAREN          reduce using rule 82 (expression -> pointervar .)
    SEMICOLON       reduce using rule 82 (expression -> pointervar .)
    COMMA           reduce using rule 82 (expression -> pointervar .)
    ANDOPERATOR     reduce using rule 82 (expression -> pointervar .)
    OROPERATOR      reduce using rule 82 (expression -> pointervar .)


state 65

    (81) allnumbers -> NUMBER .

    PLUS            reduce using rule 81 (allnumbers -> NUMBER .)
    MINUS           reduce using rule 81 (allnumbers -> NUMBER .)
    DIVIDE          reduce using rule 81 (allnumbers -> NUMBER .)
    TIMES           reduce using rule 81 (allnumbers -> NUMBER .)
    SEMICOLON       reduce using rule 81 (allnumbers -> NUMBER .)
    LESSTHANEQ      reduce using rule 81 (allnumbers -> NUMBER .)
    GREATERTHANEQ   reduce using rule 81 (allnumbers -> NUMBER .)
    UNEQUAL         reduce using rule 81 (allnumbers -> NUMBER .)
    EQUALCHECK      reduce using rule 81 (allnumbers -> NUMBER .)
    LESSTHAN        reduce using rule 81 (allnumbers -> NUMBER .)
    GREATERTHAN     reduce using rule 81 (allnumbers -> NUMBER .)
    RPAREN          reduce using rule 81 (allnumbers -> NUMBER .)
    COMMA           reduce using rule 81 (allnumbers -> NUMBER .)
    ANDOPERATOR     reduce using rule 81 (allnumbers -> NUMBER .)
    OROPERATOR      reduce using rule 81 (allnumbers -> NUMBER .)


state 66

    (83) pointervar -> TIMES . pointervar
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62
    NAME            shift and go to state 74

    pointervar                     shift and go to state 85

state 67

    (72) expression -> functioncall .

    PLUS            reduce using rule 72 (expression -> functioncall .)
    MINUS           reduce using rule 72 (expression -> functioncall .)
    DIVIDE          reduce using rule 72 (expression -> functioncall .)
    TIMES           reduce using rule 72 (expression -> functioncall .)
    LESSTHANEQ      reduce using rule 72 (expression -> functioncall .)
    GREATERTHANEQ   reduce using rule 72 (expression -> functioncall .)
    UNEQUAL         reduce using rule 72 (expression -> functioncall .)
    EQUALCHECK      reduce using rule 72 (expression -> functioncall .)
    LESSTHAN        reduce using rule 72 (expression -> functioncall .)
    GREATERTHAN     reduce using rule 72 (expression -> functioncall .)
    RPAREN          reduce using rule 72 (expression -> functioncall .)
    SEMICOLON       reduce using rule 72 (expression -> functioncall .)
    COMMA           reduce using rule 72 (expression -> functioncall .)
    ANDOPERATOR     reduce using rule 72 (expression -> functioncall .)
    OROPERATOR      reduce using rule 72 (expression -> functioncall .)


state 68

    (78) expression -> LPAREN . expression RPAREN
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 68
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    functioncall                   shift and go to state 67
    pointervar                     shift and go to state 64
    allnumbers                     shift and go to state 63
    expression                     shift and go to state 86

state 69

    (28) returnstatement -> RETURN expression . SEMICOLON
    (73) expression -> expression . PLUS expression
    (74) expression -> expression . MINUS expression
    (75) expression -> expression . DIVIDE expression
    (76) expression -> expression . TIMES expression

    SEMICOLON       shift and go to state 88
    PLUS            shift and go to state 90
    MINUS           shift and go to state 91
    DIVIDE          shift and go to state 87
    TIMES           shift and go to state 89


state 70

    (77) expression -> MINUS . expression
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 68
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    functioncall                   shift and go to state 67
    pointervar                     shift and go to state 64
    allnumbers                     shift and go to state 63
    expression                     shift and go to state 92

state 71

    (42) whileblock -> WHILE LPAREN . conditional RPAREN LBRACE fbody RBRACE
    (43) conditional -> . LPAREN conditional RPAREN
    (44) conditional -> . conditionbase
    (45) conditional -> . NOT LPAREN conditional RPAREN
    (46) conditional -> . conditional LESSTHANEQ conditional
    (47) conditional -> . conditional GREATERTHANEQ conditional
    (48) conditional -> . conditional UNEQUAL conditional
    (49) conditional -> . conditional EQUALCHECK conditional
    (50) conditional -> . conditional LESSTHAN conditional
    (51) conditional -> . conditional GREATERTHAN conditional
    (52) conditional -> . conditional ANDOPERATOR conditional
    (53) conditional -> . conditional OROPERATOR conditional
    (54) conditionbase -> . CS LESSTHANEQ CS
    (55) conditionbase -> . CS GREATERTHANEQ CS
    (56) conditionbase -> . CS UNEQUAL CS
    (57) conditionbase -> . CS EQUALCHECK CS
    (58) conditionbase -> . CS LESSTHAN CS
    (59) conditionbase -> . CS GREATERTHAN CS
    (60) CS -> . expression
    (61) CS -> . NOT LPAREN expression RPAREN
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    LPAREN          shift and go to state 95
    NOT             shift and go to state 97
    MINUS           shift and go to state 70
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    allnumbers                     shift and go to state 63
    pointervar                     shift and go to state 64
    conditionbase                  shift and go to state 93
    conditional                    shift and go to state 94
    functioncall                   shift and go to state 67
    CS                             shift and go to state 96
    expression                     shift and go to state 98

state 72

    (27) statement -> functioncall SEMICOLON .

    SEMICOLON       reduce using rule 27 (statement -> functioncall SEMICOLON .)
    IF              reduce using rule 27 (statement -> functioncall SEMICOLON .)
    TYPE            reduce using rule 27 (statement -> functioncall SEMICOLON .)
    WHILE           reduce using rule 27 (statement -> functioncall SEMICOLON .)
    RETURN          reduce using rule 27 (statement -> functioncall SEMICOLON .)
    NAME            reduce using rule 27 (statement -> functioncall SEMICOLON .)
    TIMES           reduce using rule 27 (statement -> functioncall SEMICOLON .)
    RBRACE          reduce using rule 27 (statement -> functioncall SEMICOLON .)
    ELSE            reduce using rule 27 (statement -> functioncall SEMICOLON .)


state 73

    (69) assignment -> assignment_base SEMICOLON .

    SEMICOLON       reduce using rule 69 (assignment -> assignment_base SEMICOLON .)
    IF              reduce using rule 69 (assignment -> assignment_base SEMICOLON .)
    TYPE            reduce using rule 69 (assignment -> assignment_base SEMICOLON .)
    WHILE           reduce using rule 69 (assignment -> assignment_base SEMICOLON .)
    RETURN          reduce using rule 69 (assignment -> assignment_base SEMICOLON .)
    NAME            reduce using rule 69 (assignment -> assignment_base SEMICOLON .)
    TIMES           reduce using rule 69 (assignment -> assignment_base SEMICOLON .)
    RBRACE          reduce using rule 69 (assignment -> assignment_base SEMICOLON .)
    ELSE            reduce using rule 69 (assignment -> assignment_base SEMICOLON .)


state 74

    (85) pointervar -> NAME .

    SEMICOLON       reduce using rule 85 (pointervar -> NAME .)
    PLUS            reduce using rule 85 (pointervar -> NAME .)
    MINUS           reduce using rule 85 (pointervar -> NAME .)
    DIVIDE          reduce using rule 85 (pointervar -> NAME .)
    TIMES           reduce using rule 85 (pointervar -> NAME .)
    EQUALS          reduce using rule 85 (pointervar -> NAME .)
    RPAREN          reduce using rule 85 (pointervar -> NAME .)
    LESSTHANEQ      reduce using rule 85 (pointervar -> NAME .)
    GREATERTHANEQ   reduce using rule 85 (pointervar -> NAME .)
    UNEQUAL         reduce using rule 85 (pointervar -> NAME .)
    EQUALCHECK      reduce using rule 85 (pointervar -> NAME .)
    LESSTHAN        reduce using rule 85 (pointervar -> NAME .)
    GREATERTHAN     reduce using rule 85 (pointervar -> NAME .)
    COMMA           reduce using rule 85 (pointervar -> NAME .)
    ANDOPERATOR     reduce using rule 85 (pointervar -> NAME .)
    OROPERATOR      reduce using rule 85 (pointervar -> NAME .)


state 75

    (70) assignment_base -> TIMES pointervar . EQUALS expression

    EQUALS          shift and go to state 99


state 76

    (10) function -> TYPE NAME LPAREN paramlist RPAREN LBRACE fbody RBRACE .

    TYPE            reduce using rule 10 (function -> TYPE NAME LPAREN paramlist RPAREN LBRACE fbody RBRACE .)
    $end            reduce using rule 10 (function -> TYPE NAME LPAREN paramlist RPAREN LBRACE fbody RBRACE .)


state 77

    (34) unmatchedstatement -> IF LPAREN . conditional RPAREN allstatement
    (35) unmatchedstatement -> IF LPAREN . conditional RPAREN statement ELSE unmatchedstatement
    (36) unmatchedstatement -> IF LPAREN . conditional RPAREN LBRACE fbody RBRACE ELSE unmatchedstatement
    (37) unmatchedstatement -> IF LPAREN . conditional RPAREN LBRACE fbody RBRACE
    (38) ifblock -> IF LPAREN . conditional RPAREN statement ELSE statement
    (39) ifblock -> IF LPAREN . conditional RPAREN statement ELSE LBRACE fbody RBRACE
    (40) ifblock -> IF LPAREN . conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE
    (41) ifblock -> IF LPAREN . conditional RPAREN LBRACE fbody RBRACE ELSE statement
    (43) conditional -> . LPAREN conditional RPAREN
    (44) conditional -> . conditionbase
    (45) conditional -> . NOT LPAREN conditional RPAREN
    (46) conditional -> . conditional LESSTHANEQ conditional
    (47) conditional -> . conditional GREATERTHANEQ conditional
    (48) conditional -> . conditional UNEQUAL conditional
    (49) conditional -> . conditional EQUALCHECK conditional
    (50) conditional -> . conditional LESSTHAN conditional
    (51) conditional -> . conditional GREATERTHAN conditional
    (52) conditional -> . conditional ANDOPERATOR conditional
    (53) conditional -> . conditional OROPERATOR conditional
    (54) conditionbase -> . CS LESSTHANEQ CS
    (55) conditionbase -> . CS GREATERTHANEQ CS
    (56) conditionbase -> . CS UNEQUAL CS
    (57) conditionbase -> . CS EQUALCHECK CS
    (58) conditionbase -> . CS LESSTHAN CS
    (59) conditionbase -> . CS GREATERTHAN CS
    (60) CS -> . expression
    (61) CS -> . NOT LPAREN expression RPAREN
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    LPAREN          shift and go to state 95
    NOT             shift and go to state 97
    MINUS           shift and go to state 70
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    allnumbers                     shift and go to state 63
    pointervar                     shift and go to state 64
    conditionbase                  shift and go to state 93
    conditional                    shift and go to state 100
    CS                             shift and go to state 96
    functioncall                   shift and go to state 67
    expression                     shift and go to state 98

state 78

    (71) assignment_base -> NAME EQUALS . expression
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 68
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    functioncall                   shift and go to state 67
    pointervar                     shift and go to state 64
    allnumbers                     shift and go to state 63
    expression                     shift and go to state 101

state 79

    (30) functioncall -> NAME LPAREN . arguments RPAREN
    (31) arguments -> . expression
    (32) arguments -> . expression COMMA arguments
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 68
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    functioncall                   shift and go to state 67
    pointervar                     shift and go to state 64
    allnumbers                     shift and go to state 63
    expression                     shift and go to state 103
    arguments                      shift and go to state 102

state 80

    (18) fbody -> allstatement fbody .

    RBRACE          reduce using rule 18 (fbody -> allstatement fbody .)


state 81

    (16) paramlist2 -> COMMA TYPE NAME . paramlist2
    (15) paramlist2 -> .
    (16) paramlist2 -> . COMMA TYPE NAME paramlist2
    (17) paramlist2 -> . COMMA TYPE specialvar paramlist2

    RPAREN          reduce using rule 15 (paramlist2 -> .)
    COMMA           shift and go to state 34

    paramlist2                     shift and go to state 104

state 82

    (17) paramlist2 -> COMMA TYPE specialvar . paramlist2
    (15) paramlist2 -> .
    (16) paramlist2 -> . COMMA TYPE NAME paramlist2
    (17) paramlist2 -> . COMMA TYPE specialvar paramlist2

    RPAREN          reduce using rule 15 (paramlist2 -> .)
    COMMA           shift and go to state 34

    paramlist2                     shift and go to state 105

state 83

    (11) function -> TYPE specialvar LPAREN paramlist RPAREN LBRACE fbody RBRACE .

    TYPE            reduce using rule 11 (function -> TYPE specialvar LPAREN paramlist RPAREN LBRACE fbody RBRACE .)
    $end            reduce using rule 11 (function -> TYPE specialvar LPAREN paramlist RPAREN LBRACE fbody RBRACE .)


state 84

    (84) pointervar -> ADDROF pointervar .

    PLUS            reduce using rule 84 (pointervar -> ADDROF pointervar .)
    MINUS           reduce using rule 84 (pointervar -> ADDROF pointervar .)
    DIVIDE          reduce using rule 84 (pointervar -> ADDROF pointervar .)
    TIMES           reduce using rule 84 (pointervar -> ADDROF pointervar .)
    SEMICOLON       reduce using rule 84 (pointervar -> ADDROF pointervar .)
    RPAREN          reduce using rule 84 (pointervar -> ADDROF pointervar .)
    LESSTHANEQ      reduce using rule 84 (pointervar -> ADDROF pointervar .)
    GREATERTHANEQ   reduce using rule 84 (pointervar -> ADDROF pointervar .)
    UNEQUAL         reduce using rule 84 (pointervar -> ADDROF pointervar .)
    EQUALCHECK      reduce using rule 84 (pointervar -> ADDROF pointervar .)
    LESSTHAN        reduce using rule 84 (pointervar -> ADDROF pointervar .)
    GREATERTHAN     reduce using rule 84 (pointervar -> ADDROF pointervar .)
    COMMA           reduce using rule 84 (pointervar -> ADDROF pointervar .)
    ANDOPERATOR     reduce using rule 84 (pointervar -> ADDROF pointervar .)
    OROPERATOR      reduce using rule 84 (pointervar -> ADDROF pointervar .)
    EQUALS          reduce using rule 84 (pointervar -> ADDROF pointervar .)


state 85

    (83) pointervar -> TIMES pointervar .

    PLUS            reduce using rule 83 (pointervar -> TIMES pointervar .)
    MINUS           reduce using rule 83 (pointervar -> TIMES pointervar .)
    DIVIDE          reduce using rule 83 (pointervar -> TIMES pointervar .)
    TIMES           reduce using rule 83 (pointervar -> TIMES pointervar .)
    SEMICOLON       reduce using rule 83 (pointervar -> TIMES pointervar .)
    RPAREN          reduce using rule 83 (pointervar -> TIMES pointervar .)
    LESSTHANEQ      reduce using rule 83 (pointervar -> TIMES pointervar .)
    GREATERTHANEQ   reduce using rule 83 (pointervar -> TIMES pointervar .)
    UNEQUAL         reduce using rule 83 (pointervar -> TIMES pointervar .)
    EQUALCHECK      reduce using rule 83 (pointervar -> TIMES pointervar .)
    LESSTHAN        reduce using rule 83 (pointervar -> TIMES pointervar .)
    GREATERTHAN     reduce using rule 83 (pointervar -> TIMES pointervar .)
    COMMA           reduce using rule 83 (pointervar -> TIMES pointervar .)
    ANDOPERATOR     reduce using rule 83 (pointervar -> TIMES pointervar .)
    OROPERATOR      reduce using rule 83 (pointervar -> TIMES pointervar .)
    EQUALS          reduce using rule 83 (pointervar -> TIMES pointervar .)


state 86

    (78) expression -> LPAREN expression . RPAREN
    (73) expression -> expression . PLUS expression
    (74) expression -> expression . MINUS expression
    (75) expression -> expression . DIVIDE expression
    (76) expression -> expression . TIMES expression

    RPAREN          shift and go to state 106
    PLUS            shift and go to state 90
    MINUS           shift and go to state 91
    DIVIDE          shift and go to state 87
    TIMES           shift and go to state 89


state 87

    (75) expression -> expression DIVIDE . expression
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 68
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    functioncall                   shift and go to state 67
    pointervar                     shift and go to state 64
    allnumbers                     shift and go to state 63
    expression                     shift and go to state 107

state 88

    (28) returnstatement -> RETURN expression SEMICOLON .

    SEMICOLON       reduce using rule 28 (returnstatement -> RETURN expression SEMICOLON .)
    IF              reduce using rule 28 (returnstatement -> RETURN expression SEMICOLON .)
    TYPE            reduce using rule 28 (returnstatement -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 28 (returnstatement -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 28 (returnstatement -> RETURN expression SEMICOLON .)
    NAME            reduce using rule 28 (returnstatement -> RETURN expression SEMICOLON .)
    TIMES           reduce using rule 28 (returnstatement -> RETURN expression SEMICOLON .)
    RBRACE          reduce using rule 28 (returnstatement -> RETURN expression SEMICOLON .)
    ELSE            reduce using rule 28 (returnstatement -> RETURN expression SEMICOLON .)


state 89

    (76) expression -> expression TIMES . expression
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 68
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    functioncall                   shift and go to state 67
    pointervar                     shift and go to state 64
    allnumbers                     shift and go to state 63
    expression                     shift and go to state 108

state 90

    (73) expression -> expression PLUS . expression
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 68
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    functioncall                   shift and go to state 67
    pointervar                     shift and go to state 64
    allnumbers                     shift and go to state 63
    expression                     shift and go to state 109

state 91

    (74) expression -> expression MINUS . expression
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 68
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    functioncall                   shift and go to state 67
    pointervar                     shift and go to state 64
    allnumbers                     shift and go to state 63
    expression                     shift and go to state 110

state 92

    (77) expression -> MINUS expression .
    (73) expression -> expression . PLUS expression
    (74) expression -> expression . MINUS expression
    (75) expression -> expression . DIVIDE expression
    (76) expression -> expression . TIMES expression

    PLUS            reduce using rule 77 (expression -> MINUS expression .)
    MINUS           reduce using rule 77 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 77 (expression -> MINUS expression .)
    TIMES           reduce using rule 77 (expression -> MINUS expression .)
    LESSTHANEQ      reduce using rule 77 (expression -> MINUS expression .)
    GREATERTHANEQ   reduce using rule 77 (expression -> MINUS expression .)
    UNEQUAL         reduce using rule 77 (expression -> MINUS expression .)
    EQUALCHECK      reduce using rule 77 (expression -> MINUS expression .)
    LESSTHAN        reduce using rule 77 (expression -> MINUS expression .)
    GREATERTHAN     reduce using rule 77 (expression -> MINUS expression .)
    RPAREN          reduce using rule 77 (expression -> MINUS expression .)
    SEMICOLON       reduce using rule 77 (expression -> MINUS expression .)
    COMMA           reduce using rule 77 (expression -> MINUS expression .)
    ANDOPERATOR     reduce using rule 77 (expression -> MINUS expression .)
    OROPERATOR      reduce using rule 77 (expression -> MINUS expression .)

  ! PLUS            [ shift and go to state 90 ]
  ! MINUS           [ shift and go to state 91 ]
  ! DIVIDE          [ shift and go to state 87 ]
  ! TIMES           [ shift and go to state 89 ]


state 93

    (44) conditional -> conditionbase .

    LESSTHANEQ      reduce using rule 44 (conditional -> conditionbase .)
    GREATERTHANEQ   reduce using rule 44 (conditional -> conditionbase .)
    UNEQUAL         reduce using rule 44 (conditional -> conditionbase .)
    EQUALCHECK      reduce using rule 44 (conditional -> conditionbase .)
    LESSTHAN        reduce using rule 44 (conditional -> conditionbase .)
    GREATERTHAN     reduce using rule 44 (conditional -> conditionbase .)
    ANDOPERATOR     reduce using rule 44 (conditional -> conditionbase .)
    OROPERATOR      reduce using rule 44 (conditional -> conditionbase .)
    RPAREN          reduce using rule 44 (conditional -> conditionbase .)


state 94

    (42) whileblock -> WHILE LPAREN conditional . RPAREN LBRACE fbody RBRACE
    (46) conditional -> conditional . LESSTHANEQ conditional
    (47) conditional -> conditional . GREATERTHANEQ conditional
    (48) conditional -> conditional . UNEQUAL conditional
    (49) conditional -> conditional . EQUALCHECK conditional
    (50) conditional -> conditional . LESSTHAN conditional
    (51) conditional -> conditional . GREATERTHAN conditional
    (52) conditional -> conditional . ANDOPERATOR conditional
    (53) conditional -> conditional . OROPERATOR conditional

    RPAREN          shift and go to state 111
    LESSTHANEQ      shift and go to state 118
    GREATERTHANEQ   shift and go to state 116
    UNEQUAL         shift and go to state 117
    EQUALCHECK      shift and go to state 119
    LESSTHAN        shift and go to state 113
    GREATERTHAN     shift and go to state 112
    ANDOPERATOR     shift and go to state 115
    OROPERATOR      shift and go to state 114


state 95

    (43) conditional -> LPAREN . conditional RPAREN
    (78) expression -> LPAREN . expression RPAREN
    (43) conditional -> . LPAREN conditional RPAREN
    (44) conditional -> . conditionbase
    (45) conditional -> . NOT LPAREN conditional RPAREN
    (46) conditional -> . conditional LESSTHANEQ conditional
    (47) conditional -> . conditional GREATERTHANEQ conditional
    (48) conditional -> . conditional UNEQUAL conditional
    (49) conditional -> . conditional EQUALCHECK conditional
    (50) conditional -> . conditional LESSTHAN conditional
    (51) conditional -> . conditional GREATERTHAN conditional
    (52) conditional -> . conditional ANDOPERATOR conditional
    (53) conditional -> . conditional OROPERATOR conditional
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (54) conditionbase -> . CS LESSTHANEQ CS
    (55) conditionbase -> . CS GREATERTHANEQ CS
    (56) conditionbase -> . CS UNEQUAL CS
    (57) conditionbase -> . CS EQUALCHECK CS
    (58) conditionbase -> . CS LESSTHAN CS
    (59) conditionbase -> . CS GREATERTHAN CS
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME
    (60) CS -> . expression
    (61) CS -> . NOT LPAREN expression RPAREN

    LPAREN          shift and go to state 95
    NOT             shift and go to state 97
    MINUS           shift and go to state 70
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    allnumbers                     shift and go to state 63
    pointervar                     shift and go to state 64
    conditionbase                  shift and go to state 93
    conditional                    shift and go to state 120
    functioncall                   shift and go to state 67
    CS                             shift and go to state 96
    expression                     shift and go to state 121

state 96

    (54) conditionbase -> CS . LESSTHANEQ CS
    (55) conditionbase -> CS . GREATERTHANEQ CS
    (56) conditionbase -> CS . UNEQUAL CS
    (57) conditionbase -> CS . EQUALCHECK CS
    (58) conditionbase -> CS . LESSTHAN CS
    (59) conditionbase -> CS . GREATERTHAN CS

    LESSTHANEQ      shift and go to state 126
    GREATERTHANEQ   shift and go to state 124
    UNEQUAL         shift and go to state 122
    EQUALCHECK      shift and go to state 127
    LESSTHAN        shift and go to state 123
    GREATERTHAN     shift and go to state 125


state 97

    (45) conditional -> NOT . LPAREN conditional RPAREN
    (61) CS -> NOT . LPAREN expression RPAREN

    LPAREN          shift and go to state 128


state 98

    (60) CS -> expression .
    (73) expression -> expression . PLUS expression
    (74) expression -> expression . MINUS expression
    (75) expression -> expression . DIVIDE expression
    (76) expression -> expression . TIMES expression

    LESSTHANEQ      reduce using rule 60 (CS -> expression .)
    GREATERTHANEQ   reduce using rule 60 (CS -> expression .)
    UNEQUAL         reduce using rule 60 (CS -> expression .)
    EQUALCHECK      reduce using rule 60 (CS -> expression .)
    LESSTHAN        reduce using rule 60 (CS -> expression .)
    GREATERTHAN     reduce using rule 60 (CS -> expression .)
    RPAREN          reduce using rule 60 (CS -> expression .)
    ANDOPERATOR     reduce using rule 60 (CS -> expression .)
    OROPERATOR      reduce using rule 60 (CS -> expression .)
    PLUS            shift and go to state 90
    MINUS           shift and go to state 91
    DIVIDE          shift and go to state 87
    TIMES           shift and go to state 89


state 99

    (70) assignment_base -> TIMES pointervar EQUALS . expression
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 68
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    expression                     shift and go to state 129
    allnumbers                     shift and go to state 63
    pointervar                     shift and go to state 64
    functioncall                   shift and go to state 67

state 100

    (34) unmatchedstatement -> IF LPAREN conditional . RPAREN allstatement
    (35) unmatchedstatement -> IF LPAREN conditional . RPAREN statement ELSE unmatchedstatement
    (36) unmatchedstatement -> IF LPAREN conditional . RPAREN LBRACE fbody RBRACE ELSE unmatchedstatement
    (37) unmatchedstatement -> IF LPAREN conditional . RPAREN LBRACE fbody RBRACE
    (38) ifblock -> IF LPAREN conditional . RPAREN statement ELSE statement
    (39) ifblock -> IF LPAREN conditional . RPAREN statement ELSE LBRACE fbody RBRACE
    (40) ifblock -> IF LPAREN conditional . RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE
    (41) ifblock -> IF LPAREN conditional . RPAREN LBRACE fbody RBRACE ELSE statement
    (46) conditional -> conditional . LESSTHANEQ conditional
    (47) conditional -> conditional . GREATERTHANEQ conditional
    (48) conditional -> conditional . UNEQUAL conditional
    (49) conditional -> conditional . EQUALCHECK conditional
    (50) conditional -> conditional . LESSTHAN conditional
    (51) conditional -> conditional . GREATERTHAN conditional
    (52) conditional -> conditional . ANDOPERATOR conditional
    (53) conditional -> conditional . OROPERATOR conditional

    RPAREN          shift and go to state 130
    LESSTHANEQ      shift and go to state 118
    GREATERTHANEQ   shift and go to state 116
    UNEQUAL         shift and go to state 117
    EQUALCHECK      shift and go to state 119
    LESSTHAN        shift and go to state 113
    GREATERTHAN     shift and go to state 112
    ANDOPERATOR     shift and go to state 115
    OROPERATOR      shift and go to state 114


state 101

    (71) assignment_base -> NAME EQUALS expression .
    (73) expression -> expression . PLUS expression
    (74) expression -> expression . MINUS expression
    (75) expression -> expression . DIVIDE expression
    (76) expression -> expression . TIMES expression

    SEMICOLON       reduce using rule 71 (assignment_base -> NAME EQUALS expression .)
    PLUS            shift and go to state 90
    MINUS           shift and go to state 91
    DIVIDE          shift and go to state 87
    TIMES           shift and go to state 89


state 102

    (30) functioncall -> NAME LPAREN arguments . RPAREN

    RPAREN          shift and go to state 131


state 103

    (31) arguments -> expression .
    (32) arguments -> expression . COMMA arguments
    (73) expression -> expression . PLUS expression
    (74) expression -> expression . MINUS expression
    (75) expression -> expression . DIVIDE expression
    (76) expression -> expression . TIMES expression

    RPAREN          reduce using rule 31 (arguments -> expression .)
    COMMA           shift and go to state 132
    PLUS            shift and go to state 90
    MINUS           shift and go to state 91
    DIVIDE          shift and go to state 87
    TIMES           shift and go to state 89


state 104

    (16) paramlist2 -> COMMA TYPE NAME paramlist2 .

    RPAREN          reduce using rule 16 (paramlist2 -> COMMA TYPE NAME paramlist2 .)


state 105

    (17) paramlist2 -> COMMA TYPE specialvar paramlist2 .

    RPAREN          reduce using rule 17 (paramlist2 -> COMMA TYPE specialvar paramlist2 .)


state 106

    (78) expression -> LPAREN expression RPAREN .

    PLUS            reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    LESSTHANEQ      reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    GREATERTHANEQ   reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    UNEQUAL         reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    EQUALCHECK      reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    LESSTHAN        reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    GREATERTHAN     reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    ANDOPERATOR     reduce using rule 78 (expression -> LPAREN expression RPAREN .)
    OROPERATOR      reduce using rule 78 (expression -> LPAREN expression RPAREN .)


state 107

    (75) expression -> expression DIVIDE expression .
    (73) expression -> expression . PLUS expression
    (74) expression -> expression . MINUS expression
    (75) expression -> expression . DIVIDE expression
    (76) expression -> expression . TIMES expression

    PLUS            reduce using rule 75 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 75 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 75 (expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 75 (expression -> expression DIVIDE expression .)
    LESSTHANEQ      reduce using rule 75 (expression -> expression DIVIDE expression .)
    GREATERTHANEQ   reduce using rule 75 (expression -> expression DIVIDE expression .)
    UNEQUAL         reduce using rule 75 (expression -> expression DIVIDE expression .)
    EQUALCHECK      reduce using rule 75 (expression -> expression DIVIDE expression .)
    LESSTHAN        reduce using rule 75 (expression -> expression DIVIDE expression .)
    GREATERTHAN     reduce using rule 75 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 75 (expression -> expression DIVIDE expression .)
    SEMICOLON       reduce using rule 75 (expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 75 (expression -> expression DIVIDE expression .)
    ANDOPERATOR     reduce using rule 75 (expression -> expression DIVIDE expression .)
    OROPERATOR      reduce using rule 75 (expression -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 90 ]
  ! MINUS           [ shift and go to state 91 ]
  ! DIVIDE          [ shift and go to state 87 ]
  ! TIMES           [ shift and go to state 89 ]


state 108

    (76) expression -> expression TIMES expression .
    (73) expression -> expression . PLUS expression
    (74) expression -> expression . MINUS expression
    (75) expression -> expression . DIVIDE expression
    (76) expression -> expression . TIMES expression

    PLUS            reduce using rule 76 (expression -> expression TIMES expression .)
    MINUS           reduce using rule 76 (expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 76 (expression -> expression TIMES expression .)
    TIMES           reduce using rule 76 (expression -> expression TIMES expression .)
    LESSTHANEQ      reduce using rule 76 (expression -> expression TIMES expression .)
    GREATERTHANEQ   reduce using rule 76 (expression -> expression TIMES expression .)
    UNEQUAL         reduce using rule 76 (expression -> expression TIMES expression .)
    EQUALCHECK      reduce using rule 76 (expression -> expression TIMES expression .)
    LESSTHAN        reduce using rule 76 (expression -> expression TIMES expression .)
    GREATERTHAN     reduce using rule 76 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 76 (expression -> expression TIMES expression .)
    SEMICOLON       reduce using rule 76 (expression -> expression TIMES expression .)
    COMMA           reduce using rule 76 (expression -> expression TIMES expression .)
    ANDOPERATOR     reduce using rule 76 (expression -> expression TIMES expression .)
    OROPERATOR      reduce using rule 76 (expression -> expression TIMES expression .)

  ! PLUS            [ shift and go to state 90 ]
  ! MINUS           [ shift and go to state 91 ]
  ! DIVIDE          [ shift and go to state 87 ]
  ! TIMES           [ shift and go to state 89 ]


state 109

    (73) expression -> expression PLUS expression .
    (73) expression -> expression . PLUS expression
    (74) expression -> expression . MINUS expression
    (75) expression -> expression . DIVIDE expression
    (76) expression -> expression . TIMES expression

    PLUS            reduce using rule 73 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 73 (expression -> expression PLUS expression .)
    LESSTHANEQ      reduce using rule 73 (expression -> expression PLUS expression .)
    GREATERTHANEQ   reduce using rule 73 (expression -> expression PLUS expression .)
    UNEQUAL         reduce using rule 73 (expression -> expression PLUS expression .)
    EQUALCHECK      reduce using rule 73 (expression -> expression PLUS expression .)
    LESSTHAN        reduce using rule 73 (expression -> expression PLUS expression .)
    GREATERTHAN     reduce using rule 73 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 73 (expression -> expression PLUS expression .)
    SEMICOLON       reduce using rule 73 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 73 (expression -> expression PLUS expression .)
    ANDOPERATOR     reduce using rule 73 (expression -> expression PLUS expression .)
    OROPERATOR      reduce using rule 73 (expression -> expression PLUS expression .)
    DIVIDE          shift and go to state 87
    TIMES           shift and go to state 89

  ! DIVIDE          [ reduce using rule 73 (expression -> expression PLUS expression .) ]
  ! TIMES           [ reduce using rule 73 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 90 ]
  ! MINUS           [ shift and go to state 91 ]


state 110

    (74) expression -> expression MINUS expression .
    (73) expression -> expression . PLUS expression
    (74) expression -> expression . MINUS expression
    (75) expression -> expression . DIVIDE expression
    (76) expression -> expression . TIMES expression

    PLUS            reduce using rule 74 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 74 (expression -> expression MINUS expression .)
    LESSTHANEQ      reduce using rule 74 (expression -> expression MINUS expression .)
    GREATERTHANEQ   reduce using rule 74 (expression -> expression MINUS expression .)
    UNEQUAL         reduce using rule 74 (expression -> expression MINUS expression .)
    EQUALCHECK      reduce using rule 74 (expression -> expression MINUS expression .)
    LESSTHAN        reduce using rule 74 (expression -> expression MINUS expression .)
    GREATERTHAN     reduce using rule 74 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 74 (expression -> expression MINUS expression .)
    SEMICOLON       reduce using rule 74 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 74 (expression -> expression MINUS expression .)
    ANDOPERATOR     reduce using rule 74 (expression -> expression MINUS expression .)
    OROPERATOR      reduce using rule 74 (expression -> expression MINUS expression .)
    DIVIDE          shift and go to state 87
    TIMES           shift and go to state 89

  ! DIVIDE          [ reduce using rule 74 (expression -> expression MINUS expression .) ]
  ! TIMES           [ reduce using rule 74 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 90 ]
  ! MINUS           [ shift and go to state 91 ]


state 111

    (42) whileblock -> WHILE LPAREN conditional RPAREN . LBRACE fbody RBRACE

    LBRACE          shift and go to state 133


state 112

    (51) conditional -> conditional GREATERTHAN . conditional
    (43) conditional -> . LPAREN conditional RPAREN
    (44) conditional -> . conditionbase
    (45) conditional -> . NOT LPAREN conditional RPAREN
    (46) conditional -> . conditional LESSTHANEQ conditional
    (47) conditional -> . conditional GREATERTHANEQ conditional
    (48) conditional -> . conditional UNEQUAL conditional
    (49) conditional -> . conditional EQUALCHECK conditional
    (50) conditional -> . conditional LESSTHAN conditional
    (51) conditional -> . conditional GREATERTHAN conditional
    (52) conditional -> . conditional ANDOPERATOR conditional
    (53) conditional -> . conditional OROPERATOR conditional
    (54) conditionbase -> . CS LESSTHANEQ CS
    (55) conditionbase -> . CS GREATERTHANEQ CS
    (56) conditionbase -> . CS UNEQUAL CS
    (57) conditionbase -> . CS EQUALCHECK CS
    (58) conditionbase -> . CS LESSTHAN CS
    (59) conditionbase -> . CS GREATERTHAN CS
    (60) CS -> . expression
    (61) CS -> . NOT LPAREN expression RPAREN
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    LPAREN          shift and go to state 95
    NOT             shift and go to state 97
    MINUS           shift and go to state 70
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    allnumbers                     shift and go to state 63
    pointervar                     shift and go to state 64
    conditionbase                  shift and go to state 93
    conditional                    shift and go to state 134
    functioncall                   shift and go to state 67
    CS                             shift and go to state 96
    expression                     shift and go to state 98

state 113

    (50) conditional -> conditional LESSTHAN . conditional
    (43) conditional -> . LPAREN conditional RPAREN
    (44) conditional -> . conditionbase
    (45) conditional -> . NOT LPAREN conditional RPAREN
    (46) conditional -> . conditional LESSTHANEQ conditional
    (47) conditional -> . conditional GREATERTHANEQ conditional
    (48) conditional -> . conditional UNEQUAL conditional
    (49) conditional -> . conditional EQUALCHECK conditional
    (50) conditional -> . conditional LESSTHAN conditional
    (51) conditional -> . conditional GREATERTHAN conditional
    (52) conditional -> . conditional ANDOPERATOR conditional
    (53) conditional -> . conditional OROPERATOR conditional
    (54) conditionbase -> . CS LESSTHANEQ CS
    (55) conditionbase -> . CS GREATERTHANEQ CS
    (56) conditionbase -> . CS UNEQUAL CS
    (57) conditionbase -> . CS EQUALCHECK CS
    (58) conditionbase -> . CS LESSTHAN CS
    (59) conditionbase -> . CS GREATERTHAN CS
    (60) CS -> . expression
    (61) CS -> . NOT LPAREN expression RPAREN
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    LPAREN          shift and go to state 95
    NOT             shift and go to state 97
    MINUS           shift and go to state 70
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    allnumbers                     shift and go to state 63
    pointervar                     shift and go to state 64
    conditionbase                  shift and go to state 93
    conditional                    shift and go to state 135
    functioncall                   shift and go to state 67
    CS                             shift and go to state 96
    expression                     shift and go to state 98

state 114

    (53) conditional -> conditional OROPERATOR . conditional
    (43) conditional -> . LPAREN conditional RPAREN
    (44) conditional -> . conditionbase
    (45) conditional -> . NOT LPAREN conditional RPAREN
    (46) conditional -> . conditional LESSTHANEQ conditional
    (47) conditional -> . conditional GREATERTHANEQ conditional
    (48) conditional -> . conditional UNEQUAL conditional
    (49) conditional -> . conditional EQUALCHECK conditional
    (50) conditional -> . conditional LESSTHAN conditional
    (51) conditional -> . conditional GREATERTHAN conditional
    (52) conditional -> . conditional ANDOPERATOR conditional
    (53) conditional -> . conditional OROPERATOR conditional
    (54) conditionbase -> . CS LESSTHANEQ CS
    (55) conditionbase -> . CS GREATERTHANEQ CS
    (56) conditionbase -> . CS UNEQUAL CS
    (57) conditionbase -> . CS EQUALCHECK CS
    (58) conditionbase -> . CS LESSTHAN CS
    (59) conditionbase -> . CS GREATERTHAN CS
    (60) CS -> . expression
    (61) CS -> . NOT LPAREN expression RPAREN
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    LPAREN          shift and go to state 95
    NOT             shift and go to state 97
    MINUS           shift and go to state 70
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    allnumbers                     shift and go to state 63
    pointervar                     shift and go to state 64
    conditionbase                  shift and go to state 93
    conditional                    shift and go to state 136
    functioncall                   shift and go to state 67
    CS                             shift and go to state 96
    expression                     shift and go to state 98

state 115

    (52) conditional -> conditional ANDOPERATOR . conditional
    (43) conditional -> . LPAREN conditional RPAREN
    (44) conditional -> . conditionbase
    (45) conditional -> . NOT LPAREN conditional RPAREN
    (46) conditional -> . conditional LESSTHANEQ conditional
    (47) conditional -> . conditional GREATERTHANEQ conditional
    (48) conditional -> . conditional UNEQUAL conditional
    (49) conditional -> . conditional EQUALCHECK conditional
    (50) conditional -> . conditional LESSTHAN conditional
    (51) conditional -> . conditional GREATERTHAN conditional
    (52) conditional -> . conditional ANDOPERATOR conditional
    (53) conditional -> . conditional OROPERATOR conditional
    (54) conditionbase -> . CS LESSTHANEQ CS
    (55) conditionbase -> . CS GREATERTHANEQ CS
    (56) conditionbase -> . CS UNEQUAL CS
    (57) conditionbase -> . CS EQUALCHECK CS
    (58) conditionbase -> . CS LESSTHAN CS
    (59) conditionbase -> . CS GREATERTHAN CS
    (60) CS -> . expression
    (61) CS -> . NOT LPAREN expression RPAREN
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    LPAREN          shift and go to state 95
    NOT             shift and go to state 97
    MINUS           shift and go to state 70
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    allnumbers                     shift and go to state 63
    pointervar                     shift and go to state 64
    conditionbase                  shift and go to state 93
    conditional                    shift and go to state 137
    functioncall                   shift and go to state 67
    CS                             shift and go to state 96
    expression                     shift and go to state 98

state 116

    (47) conditional -> conditional GREATERTHANEQ . conditional
    (43) conditional -> . LPAREN conditional RPAREN
    (44) conditional -> . conditionbase
    (45) conditional -> . NOT LPAREN conditional RPAREN
    (46) conditional -> . conditional LESSTHANEQ conditional
    (47) conditional -> . conditional GREATERTHANEQ conditional
    (48) conditional -> . conditional UNEQUAL conditional
    (49) conditional -> . conditional EQUALCHECK conditional
    (50) conditional -> . conditional LESSTHAN conditional
    (51) conditional -> . conditional GREATERTHAN conditional
    (52) conditional -> . conditional ANDOPERATOR conditional
    (53) conditional -> . conditional OROPERATOR conditional
    (54) conditionbase -> . CS LESSTHANEQ CS
    (55) conditionbase -> . CS GREATERTHANEQ CS
    (56) conditionbase -> . CS UNEQUAL CS
    (57) conditionbase -> . CS EQUALCHECK CS
    (58) conditionbase -> . CS LESSTHAN CS
    (59) conditionbase -> . CS GREATERTHAN CS
    (60) CS -> . expression
    (61) CS -> . NOT LPAREN expression RPAREN
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    LPAREN          shift and go to state 95
    NOT             shift and go to state 97
    MINUS           shift and go to state 70
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    allnumbers                     shift and go to state 63
    pointervar                     shift and go to state 64
    conditionbase                  shift and go to state 93
    conditional                    shift and go to state 138
    functioncall                   shift and go to state 67
    CS                             shift and go to state 96
    expression                     shift and go to state 98

state 117

    (48) conditional -> conditional UNEQUAL . conditional
    (43) conditional -> . LPAREN conditional RPAREN
    (44) conditional -> . conditionbase
    (45) conditional -> . NOT LPAREN conditional RPAREN
    (46) conditional -> . conditional LESSTHANEQ conditional
    (47) conditional -> . conditional GREATERTHANEQ conditional
    (48) conditional -> . conditional UNEQUAL conditional
    (49) conditional -> . conditional EQUALCHECK conditional
    (50) conditional -> . conditional LESSTHAN conditional
    (51) conditional -> . conditional GREATERTHAN conditional
    (52) conditional -> . conditional ANDOPERATOR conditional
    (53) conditional -> . conditional OROPERATOR conditional
    (54) conditionbase -> . CS LESSTHANEQ CS
    (55) conditionbase -> . CS GREATERTHANEQ CS
    (56) conditionbase -> . CS UNEQUAL CS
    (57) conditionbase -> . CS EQUALCHECK CS
    (58) conditionbase -> . CS LESSTHAN CS
    (59) conditionbase -> . CS GREATERTHAN CS
    (60) CS -> . expression
    (61) CS -> . NOT LPAREN expression RPAREN
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    LPAREN          shift and go to state 95
    NOT             shift and go to state 97
    MINUS           shift and go to state 70
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    allnumbers                     shift and go to state 63
    pointervar                     shift and go to state 64
    conditionbase                  shift and go to state 93
    conditional                    shift and go to state 139
    functioncall                   shift and go to state 67
    CS                             shift and go to state 96
    expression                     shift and go to state 98

state 118

    (46) conditional -> conditional LESSTHANEQ . conditional
    (43) conditional -> . LPAREN conditional RPAREN
    (44) conditional -> . conditionbase
    (45) conditional -> . NOT LPAREN conditional RPAREN
    (46) conditional -> . conditional LESSTHANEQ conditional
    (47) conditional -> . conditional GREATERTHANEQ conditional
    (48) conditional -> . conditional UNEQUAL conditional
    (49) conditional -> . conditional EQUALCHECK conditional
    (50) conditional -> . conditional LESSTHAN conditional
    (51) conditional -> . conditional GREATERTHAN conditional
    (52) conditional -> . conditional ANDOPERATOR conditional
    (53) conditional -> . conditional OROPERATOR conditional
    (54) conditionbase -> . CS LESSTHANEQ CS
    (55) conditionbase -> . CS GREATERTHANEQ CS
    (56) conditionbase -> . CS UNEQUAL CS
    (57) conditionbase -> . CS EQUALCHECK CS
    (58) conditionbase -> . CS LESSTHAN CS
    (59) conditionbase -> . CS GREATERTHAN CS
    (60) CS -> . expression
    (61) CS -> . NOT LPAREN expression RPAREN
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    LPAREN          shift and go to state 95
    NOT             shift and go to state 97
    MINUS           shift and go to state 70
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    allnumbers                     shift and go to state 63
    pointervar                     shift and go to state 64
    conditionbase                  shift and go to state 93
    conditional                    shift and go to state 140
    functioncall                   shift and go to state 67
    CS                             shift and go to state 96
    expression                     shift and go to state 98

state 119

    (49) conditional -> conditional EQUALCHECK . conditional
    (43) conditional -> . LPAREN conditional RPAREN
    (44) conditional -> . conditionbase
    (45) conditional -> . NOT LPAREN conditional RPAREN
    (46) conditional -> . conditional LESSTHANEQ conditional
    (47) conditional -> . conditional GREATERTHANEQ conditional
    (48) conditional -> . conditional UNEQUAL conditional
    (49) conditional -> . conditional EQUALCHECK conditional
    (50) conditional -> . conditional LESSTHAN conditional
    (51) conditional -> . conditional GREATERTHAN conditional
    (52) conditional -> . conditional ANDOPERATOR conditional
    (53) conditional -> . conditional OROPERATOR conditional
    (54) conditionbase -> . CS LESSTHANEQ CS
    (55) conditionbase -> . CS GREATERTHANEQ CS
    (56) conditionbase -> . CS UNEQUAL CS
    (57) conditionbase -> . CS EQUALCHECK CS
    (58) conditionbase -> . CS LESSTHAN CS
    (59) conditionbase -> . CS GREATERTHAN CS
    (60) CS -> . expression
    (61) CS -> . NOT LPAREN expression RPAREN
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    LPAREN          shift and go to state 95
    NOT             shift and go to state 97
    MINUS           shift and go to state 70
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    allnumbers                     shift and go to state 63
    pointervar                     shift and go to state 64
    conditionbase                  shift and go to state 93
    conditional                    shift and go to state 141
    functioncall                   shift and go to state 67
    CS                             shift and go to state 96
    expression                     shift and go to state 98

state 120

    (43) conditional -> LPAREN conditional . RPAREN
    (46) conditional -> conditional . LESSTHANEQ conditional
    (47) conditional -> conditional . GREATERTHANEQ conditional
    (48) conditional -> conditional . UNEQUAL conditional
    (49) conditional -> conditional . EQUALCHECK conditional
    (50) conditional -> conditional . LESSTHAN conditional
    (51) conditional -> conditional . GREATERTHAN conditional
    (52) conditional -> conditional . ANDOPERATOR conditional
    (53) conditional -> conditional . OROPERATOR conditional

    RPAREN          shift and go to state 142
    LESSTHANEQ      shift and go to state 118
    GREATERTHANEQ   shift and go to state 116
    UNEQUAL         shift and go to state 117
    EQUALCHECK      shift and go to state 119
    LESSTHAN        shift and go to state 113
    GREATERTHAN     shift and go to state 112
    ANDOPERATOR     shift and go to state 115
    OROPERATOR      shift and go to state 114


state 121

    (78) expression -> LPAREN expression . RPAREN
    (73) expression -> expression . PLUS expression
    (74) expression -> expression . MINUS expression
    (75) expression -> expression . DIVIDE expression
    (76) expression -> expression . TIMES expression
    (60) CS -> expression .

    RPAREN          shift and go to state 106
    PLUS            shift and go to state 90
    MINUS           shift and go to state 91
    DIVIDE          shift and go to state 87
    TIMES           shift and go to state 89
    LESSTHANEQ      reduce using rule 60 (CS -> expression .)
    GREATERTHANEQ   reduce using rule 60 (CS -> expression .)
    UNEQUAL         reduce using rule 60 (CS -> expression .)
    EQUALCHECK      reduce using rule 60 (CS -> expression .)
    LESSTHAN        reduce using rule 60 (CS -> expression .)
    GREATERTHAN     reduce using rule 60 (CS -> expression .)


state 122

    (56) conditionbase -> CS UNEQUAL . CS
    (60) CS -> . expression
    (61) CS -> . NOT LPAREN expression RPAREN
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    NOT             shift and go to state 143
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 68
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    pointervar                     shift and go to state 64
    allnumbers                     shift and go to state 63
    functioncall                   shift and go to state 67
    CS                             shift and go to state 144
    expression                     shift and go to state 98

state 123

    (58) conditionbase -> CS LESSTHAN . CS
    (60) CS -> . expression
    (61) CS -> . NOT LPAREN expression RPAREN
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    NOT             shift and go to state 143
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 68
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    pointervar                     shift and go to state 64
    allnumbers                     shift and go to state 63
    functioncall                   shift and go to state 67
    CS                             shift and go to state 145
    expression                     shift and go to state 98

state 124

    (55) conditionbase -> CS GREATERTHANEQ . CS
    (60) CS -> . expression
    (61) CS -> . NOT LPAREN expression RPAREN
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    NOT             shift and go to state 143
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 68
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    pointervar                     shift and go to state 64
    allnumbers                     shift and go to state 63
    functioncall                   shift and go to state 67
    CS                             shift and go to state 146
    expression                     shift and go to state 98

state 125

    (59) conditionbase -> CS GREATERTHAN . CS
    (60) CS -> . expression
    (61) CS -> . NOT LPAREN expression RPAREN
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    NOT             shift and go to state 143
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 68
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    pointervar                     shift and go to state 64
    allnumbers                     shift and go to state 63
    functioncall                   shift and go to state 67
    CS                             shift and go to state 147
    expression                     shift and go to state 98

state 126

    (54) conditionbase -> CS LESSTHANEQ . CS
    (60) CS -> . expression
    (61) CS -> . NOT LPAREN expression RPAREN
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    NOT             shift and go to state 143
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 68
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    pointervar                     shift and go to state 64
    allnumbers                     shift and go to state 63
    functioncall                   shift and go to state 67
    CS                             shift and go to state 148
    expression                     shift and go to state 98

state 127

    (57) conditionbase -> CS EQUALCHECK . CS
    (60) CS -> . expression
    (61) CS -> . NOT LPAREN expression RPAREN
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    NOT             shift and go to state 143
    MINUS           shift and go to state 70
    LPAREN          shift and go to state 68
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    pointervar                     shift and go to state 64
    allnumbers                     shift and go to state 63
    functioncall                   shift and go to state 67
    CS                             shift and go to state 149
    expression                     shift and go to state 98

state 128

    (45) conditional -> NOT LPAREN . conditional RPAREN
    (61) CS -> NOT LPAREN . expression RPAREN
    (43) conditional -> . LPAREN conditional RPAREN
    (44) conditional -> . conditionbase
    (45) conditional -> . NOT LPAREN conditional RPAREN
    (46) conditional -> . conditional LESSTHANEQ conditional
    (47) conditional -> . conditional GREATERTHANEQ conditional
    (48) conditional -> . conditional UNEQUAL conditional
    (49) conditional -> . conditional EQUALCHECK conditional
    (50) conditional -> . conditional LESSTHAN conditional
    (51) conditional -> . conditional GREATERTHAN conditional
    (52) conditional -> . conditional ANDOPERATOR conditional
    (53) conditional -> . conditional OROPERATOR conditional
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (54) conditionbase -> . CS LESSTHANEQ CS
    (55) conditionbase -> . CS GREATERTHANEQ CS
    (56) conditionbase -> . CS UNEQUAL CS
    (57) conditionbase -> . CS EQUALCHECK CS
    (58) conditionbase -> . CS LESSTHAN CS
    (59) conditionbase -> . CS GREATERTHAN CS
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME
    (60) CS -> . expression
    (61) CS -> . NOT LPAREN expression RPAREN

    LPAREN          shift and go to state 95
    NOT             shift and go to state 97
    MINUS           shift and go to state 70
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    allnumbers                     shift and go to state 63
    pointervar                     shift and go to state 64
    conditionbase                  shift and go to state 93
    conditional                    shift and go to state 150
    functioncall                   shift and go to state 67
    CS                             shift and go to state 96
    expression                     shift and go to state 151

state 129

    (70) assignment_base -> TIMES pointervar EQUALS expression .
    (73) expression -> expression . PLUS expression
    (74) expression -> expression . MINUS expression
    (75) expression -> expression . DIVIDE expression
    (76) expression -> expression . TIMES expression

    SEMICOLON       reduce using rule 70 (assignment_base -> TIMES pointervar EQUALS expression .)
    PLUS            shift and go to state 90
    MINUS           shift and go to state 91
    DIVIDE          shift and go to state 87
    TIMES           shift and go to state 89


state 130

    (34) unmatchedstatement -> IF LPAREN conditional RPAREN . allstatement
    (35) unmatchedstatement -> IF LPAREN conditional RPAREN . statement ELSE unmatchedstatement
    (36) unmatchedstatement -> IF LPAREN conditional RPAREN . LBRACE fbody RBRACE ELSE unmatchedstatement
    (37) unmatchedstatement -> IF LPAREN conditional RPAREN . LBRACE fbody RBRACE
    (38) ifblock -> IF LPAREN conditional RPAREN . statement ELSE statement
    (39) ifblock -> IF LPAREN conditional RPAREN . statement ELSE LBRACE fbody RBRACE
    (40) ifblock -> IF LPAREN conditional RPAREN . LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE
    (41) ifblock -> IF LPAREN conditional RPAREN . LBRACE fbody RBRACE ELSE statement
    (20) allstatement -> . statement
    (21) allstatement -> . unmatchedstatement
    (22) statement -> . assignment
    (23) statement -> . declaration
    (24) statement -> . whileblock
    (25) statement -> . ifblock
    (26) statement -> . returnstatement
    (27) statement -> . functioncall SEMICOLON
    (33) statement -> . SEMICOLON
    (34) unmatchedstatement -> . IF LPAREN conditional RPAREN allstatement
    (35) unmatchedstatement -> . IF LPAREN conditional RPAREN statement ELSE unmatchedstatement
    (36) unmatchedstatement -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE unmatchedstatement
    (37) unmatchedstatement -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE
    (69) assignment -> . assignment_base SEMICOLON
    (62) declaration -> . TYPE dlist1 SEMICOLON
    (42) whileblock -> . WHILE LPAREN conditional RPAREN LBRACE fbody RBRACE
    (38) ifblock -> . IF LPAREN conditional RPAREN statement ELSE statement
    (39) ifblock -> . IF LPAREN conditional RPAREN statement ELSE LBRACE fbody RBRACE
    (40) ifblock -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE
    (41) ifblock -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE statement
    (28) returnstatement -> . RETURN expression SEMICOLON
    (29) returnstatement -> . RETURN SEMICOLON
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (70) assignment_base -> . TIMES pointervar EQUALS expression
    (71) assignment_base -> . NAME EQUALS expression

    LBRACE          shift and go to state 153
    SEMICOLON       shift and go to state 42
    IF              shift and go to state 52
    TYPE            shift and go to state 56
    WHILE           shift and go to state 40
    RETURN          shift and go to state 39
    NAME            shift and go to state 53
    TIMES           shift and go to state 50

    unmatchedstatement             shift and go to state 41
    declaration                    shift and go to state 49
    assignment                     shift and go to state 48
    whileblock                     shift and go to state 43
    ifblock                        shift and go to state 44
    allstatement                   shift and go to state 154
    statement                      shift and go to state 152
    functioncall                   shift and go to state 46
    returnstatement                shift and go to state 55
    assignment_base                shift and go to state 47

state 131

    (30) functioncall -> NAME LPAREN arguments RPAREN .

    PLUS            reduce using rule 30 (functioncall -> NAME LPAREN arguments RPAREN .)
    MINUS           reduce using rule 30 (functioncall -> NAME LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 30 (functioncall -> NAME LPAREN arguments RPAREN .)
    TIMES           reduce using rule 30 (functioncall -> NAME LPAREN arguments RPAREN .)
    LESSTHANEQ      reduce using rule 30 (functioncall -> NAME LPAREN arguments RPAREN .)
    GREATERTHANEQ   reduce using rule 30 (functioncall -> NAME LPAREN arguments RPAREN .)
    UNEQUAL         reduce using rule 30 (functioncall -> NAME LPAREN arguments RPAREN .)
    EQUALCHECK      reduce using rule 30 (functioncall -> NAME LPAREN arguments RPAREN .)
    LESSTHAN        reduce using rule 30 (functioncall -> NAME LPAREN arguments RPAREN .)
    GREATERTHAN     reduce using rule 30 (functioncall -> NAME LPAREN arguments RPAREN .)
    SEMICOLON       reduce using rule 30 (functioncall -> NAME LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 30 (functioncall -> NAME LPAREN arguments RPAREN .)
    COMMA           reduce using rule 30 (functioncall -> NAME LPAREN arguments RPAREN .)
    ANDOPERATOR     reduce using rule 30 (functioncall -> NAME LPAREN arguments RPAREN .)
    OROPERATOR      reduce using rule 30 (functioncall -> NAME LPAREN arguments RPAREN .)


state 132

    (32) arguments -> expression COMMA . arguments
    (31) arguments -> . expression
    (32) arguments -> . expression COMMA arguments
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 68
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    functioncall                   shift and go to state 67
    pointervar                     shift and go to state 64
    allnumbers                     shift and go to state 63
    expression                     shift and go to state 103
    arguments                      shift and go to state 155

state 133

    (42) whileblock -> WHILE LPAREN conditional RPAREN LBRACE . fbody RBRACE
    (18) fbody -> . allstatement fbody
    (19) fbody -> .
    (20) allstatement -> . statement
    (21) allstatement -> . unmatchedstatement
    (22) statement -> . assignment
    (23) statement -> . declaration
    (24) statement -> . whileblock
    (25) statement -> . ifblock
    (26) statement -> . returnstatement
    (27) statement -> . functioncall SEMICOLON
    (33) statement -> . SEMICOLON
    (34) unmatchedstatement -> . IF LPAREN conditional RPAREN allstatement
    (35) unmatchedstatement -> . IF LPAREN conditional RPAREN statement ELSE unmatchedstatement
    (36) unmatchedstatement -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE unmatchedstatement
    (37) unmatchedstatement -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE
    (69) assignment -> . assignment_base SEMICOLON
    (62) declaration -> . TYPE dlist1 SEMICOLON
    (42) whileblock -> . WHILE LPAREN conditional RPAREN LBRACE fbody RBRACE
    (38) ifblock -> . IF LPAREN conditional RPAREN statement ELSE statement
    (39) ifblock -> . IF LPAREN conditional RPAREN statement ELSE LBRACE fbody RBRACE
    (40) ifblock -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE
    (41) ifblock -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE statement
    (28) returnstatement -> . RETURN expression SEMICOLON
    (29) returnstatement -> . RETURN SEMICOLON
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (70) assignment_base -> . TIMES pointervar EQUALS expression
    (71) assignment_base -> . NAME EQUALS expression

    RBRACE          reduce using rule 19 (fbody -> .)
    SEMICOLON       shift and go to state 42
    IF              shift and go to state 52
    TYPE            shift and go to state 56
    WHILE           shift and go to state 40
    RETURN          shift and go to state 39
    NAME            shift and go to state 53
    TIMES           shift and go to state 50

    unmatchedstatement             shift and go to state 41
    declaration                    shift and go to state 49
    assignment                     shift and go to state 48
    whileblock                     shift and go to state 43
    ifblock                        shift and go to state 44
    allstatement                   shift and go to state 54
    statement                      shift and go to state 45
    fbody                          shift and go to state 156
    functioncall                   shift and go to state 46
    returnstatement                shift and go to state 55
    assignment_base                shift and go to state 47

state 134

    (51) conditional -> conditional GREATERTHAN conditional .
    (46) conditional -> conditional . LESSTHANEQ conditional
    (47) conditional -> conditional . GREATERTHANEQ conditional
    (48) conditional -> conditional . UNEQUAL conditional
    (49) conditional -> conditional . EQUALCHECK conditional
    (50) conditional -> conditional . LESSTHAN conditional
    (51) conditional -> conditional . GREATERTHAN conditional
    (52) conditional -> conditional . ANDOPERATOR conditional
    (53) conditional -> conditional . OROPERATOR conditional

    LESSTHANEQ      reduce using rule 51 (conditional -> conditional GREATERTHAN conditional .)
    GREATERTHANEQ   reduce using rule 51 (conditional -> conditional GREATERTHAN conditional .)
    UNEQUAL         reduce using rule 51 (conditional -> conditional GREATERTHAN conditional .)
    EQUALCHECK      reduce using rule 51 (conditional -> conditional GREATERTHAN conditional .)
    LESSTHAN        reduce using rule 51 (conditional -> conditional GREATERTHAN conditional .)
    GREATERTHAN     reduce using rule 51 (conditional -> conditional GREATERTHAN conditional .)
    ANDOPERATOR     reduce using rule 51 (conditional -> conditional GREATERTHAN conditional .)
    OROPERATOR      reduce using rule 51 (conditional -> conditional GREATERTHAN conditional .)
    RPAREN          reduce using rule 51 (conditional -> conditional GREATERTHAN conditional .)

  ! LESSTHANEQ      [ shift and go to state 118 ]
  ! GREATERTHANEQ   [ shift and go to state 116 ]
  ! UNEQUAL         [ shift and go to state 117 ]
  ! EQUALCHECK      [ shift and go to state 119 ]
  ! LESSTHAN        [ shift and go to state 113 ]
  ! GREATERTHAN     [ shift and go to state 112 ]
  ! ANDOPERATOR     [ shift and go to state 115 ]
  ! OROPERATOR      [ shift and go to state 114 ]


state 135

    (50) conditional -> conditional LESSTHAN conditional .
    (46) conditional -> conditional . LESSTHANEQ conditional
    (47) conditional -> conditional . GREATERTHANEQ conditional
    (48) conditional -> conditional . UNEQUAL conditional
    (49) conditional -> conditional . EQUALCHECK conditional
    (50) conditional -> conditional . LESSTHAN conditional
    (51) conditional -> conditional . GREATERTHAN conditional
    (52) conditional -> conditional . ANDOPERATOR conditional
    (53) conditional -> conditional . OROPERATOR conditional

    LESSTHANEQ      reduce using rule 50 (conditional -> conditional LESSTHAN conditional .)
    GREATERTHANEQ   reduce using rule 50 (conditional -> conditional LESSTHAN conditional .)
    UNEQUAL         reduce using rule 50 (conditional -> conditional LESSTHAN conditional .)
    EQUALCHECK      reduce using rule 50 (conditional -> conditional LESSTHAN conditional .)
    LESSTHAN        reduce using rule 50 (conditional -> conditional LESSTHAN conditional .)
    GREATERTHAN     reduce using rule 50 (conditional -> conditional LESSTHAN conditional .)
    ANDOPERATOR     reduce using rule 50 (conditional -> conditional LESSTHAN conditional .)
    OROPERATOR      reduce using rule 50 (conditional -> conditional LESSTHAN conditional .)
    RPAREN          reduce using rule 50 (conditional -> conditional LESSTHAN conditional .)

  ! LESSTHANEQ      [ shift and go to state 118 ]
  ! GREATERTHANEQ   [ shift and go to state 116 ]
  ! UNEQUAL         [ shift and go to state 117 ]
  ! EQUALCHECK      [ shift and go to state 119 ]
  ! LESSTHAN        [ shift and go to state 113 ]
  ! GREATERTHAN     [ shift and go to state 112 ]
  ! ANDOPERATOR     [ shift and go to state 115 ]
  ! OROPERATOR      [ shift and go to state 114 ]


state 136

    (53) conditional -> conditional OROPERATOR conditional .
    (46) conditional -> conditional . LESSTHANEQ conditional
    (47) conditional -> conditional . GREATERTHANEQ conditional
    (48) conditional -> conditional . UNEQUAL conditional
    (49) conditional -> conditional . EQUALCHECK conditional
    (50) conditional -> conditional . LESSTHAN conditional
    (51) conditional -> conditional . GREATERTHAN conditional
    (52) conditional -> conditional . ANDOPERATOR conditional
    (53) conditional -> conditional . OROPERATOR conditional

    OROPERATOR      reduce using rule 53 (conditional -> conditional OROPERATOR conditional .)
    RPAREN          reduce using rule 53 (conditional -> conditional OROPERATOR conditional .)
    LESSTHANEQ      shift and go to state 118
    GREATERTHANEQ   shift and go to state 116
    UNEQUAL         shift and go to state 117
    EQUALCHECK      shift and go to state 119
    LESSTHAN        shift and go to state 113
    GREATERTHAN     shift and go to state 112
    ANDOPERATOR     shift and go to state 115

  ! LESSTHANEQ      [ reduce using rule 53 (conditional -> conditional OROPERATOR conditional .) ]
  ! GREATERTHANEQ   [ reduce using rule 53 (conditional -> conditional OROPERATOR conditional .) ]
  ! UNEQUAL         [ reduce using rule 53 (conditional -> conditional OROPERATOR conditional .) ]
  ! EQUALCHECK      [ reduce using rule 53 (conditional -> conditional OROPERATOR conditional .) ]
  ! LESSTHAN        [ reduce using rule 53 (conditional -> conditional OROPERATOR conditional .) ]
  ! GREATERTHAN     [ reduce using rule 53 (conditional -> conditional OROPERATOR conditional .) ]
  ! ANDOPERATOR     [ reduce using rule 53 (conditional -> conditional OROPERATOR conditional .) ]
  ! OROPERATOR      [ shift and go to state 114 ]


state 137

    (52) conditional -> conditional ANDOPERATOR conditional .
    (46) conditional -> conditional . LESSTHANEQ conditional
    (47) conditional -> conditional . GREATERTHANEQ conditional
    (48) conditional -> conditional . UNEQUAL conditional
    (49) conditional -> conditional . EQUALCHECK conditional
    (50) conditional -> conditional . LESSTHAN conditional
    (51) conditional -> conditional . GREATERTHAN conditional
    (52) conditional -> conditional . ANDOPERATOR conditional
    (53) conditional -> conditional . OROPERATOR conditional

    ANDOPERATOR     reduce using rule 52 (conditional -> conditional ANDOPERATOR conditional .)
    OROPERATOR      reduce using rule 52 (conditional -> conditional ANDOPERATOR conditional .)
    RPAREN          reduce using rule 52 (conditional -> conditional ANDOPERATOR conditional .)
    LESSTHANEQ      shift and go to state 118
    GREATERTHANEQ   shift and go to state 116
    UNEQUAL         shift and go to state 117
    EQUALCHECK      shift and go to state 119
    LESSTHAN        shift and go to state 113
    GREATERTHAN     shift and go to state 112

  ! LESSTHANEQ      [ reduce using rule 52 (conditional -> conditional ANDOPERATOR conditional .) ]
  ! GREATERTHANEQ   [ reduce using rule 52 (conditional -> conditional ANDOPERATOR conditional .) ]
  ! UNEQUAL         [ reduce using rule 52 (conditional -> conditional ANDOPERATOR conditional .) ]
  ! EQUALCHECK      [ reduce using rule 52 (conditional -> conditional ANDOPERATOR conditional .) ]
  ! LESSTHAN        [ reduce using rule 52 (conditional -> conditional ANDOPERATOR conditional .) ]
  ! GREATERTHAN     [ reduce using rule 52 (conditional -> conditional ANDOPERATOR conditional .) ]
  ! ANDOPERATOR     [ shift and go to state 115 ]
  ! OROPERATOR      [ shift and go to state 114 ]


state 138

    (47) conditional -> conditional GREATERTHANEQ conditional .
    (46) conditional -> conditional . LESSTHANEQ conditional
    (47) conditional -> conditional . GREATERTHANEQ conditional
    (48) conditional -> conditional . UNEQUAL conditional
    (49) conditional -> conditional . EQUALCHECK conditional
    (50) conditional -> conditional . LESSTHAN conditional
    (51) conditional -> conditional . GREATERTHAN conditional
    (52) conditional -> conditional . ANDOPERATOR conditional
    (53) conditional -> conditional . OROPERATOR conditional

    LESSTHANEQ      reduce using rule 47 (conditional -> conditional GREATERTHANEQ conditional .)
    GREATERTHANEQ   reduce using rule 47 (conditional -> conditional GREATERTHANEQ conditional .)
    UNEQUAL         reduce using rule 47 (conditional -> conditional GREATERTHANEQ conditional .)
    EQUALCHECK      reduce using rule 47 (conditional -> conditional GREATERTHANEQ conditional .)
    LESSTHAN        reduce using rule 47 (conditional -> conditional GREATERTHANEQ conditional .)
    GREATERTHAN     reduce using rule 47 (conditional -> conditional GREATERTHANEQ conditional .)
    ANDOPERATOR     reduce using rule 47 (conditional -> conditional GREATERTHANEQ conditional .)
    OROPERATOR      reduce using rule 47 (conditional -> conditional GREATERTHANEQ conditional .)
    RPAREN          reduce using rule 47 (conditional -> conditional GREATERTHANEQ conditional .)

  ! LESSTHANEQ      [ shift and go to state 118 ]
  ! GREATERTHANEQ   [ shift and go to state 116 ]
  ! UNEQUAL         [ shift and go to state 117 ]
  ! EQUALCHECK      [ shift and go to state 119 ]
  ! LESSTHAN        [ shift and go to state 113 ]
  ! GREATERTHAN     [ shift and go to state 112 ]
  ! ANDOPERATOR     [ shift and go to state 115 ]
  ! OROPERATOR      [ shift and go to state 114 ]


state 139

    (48) conditional -> conditional UNEQUAL conditional .
    (46) conditional -> conditional . LESSTHANEQ conditional
    (47) conditional -> conditional . GREATERTHANEQ conditional
    (48) conditional -> conditional . UNEQUAL conditional
    (49) conditional -> conditional . EQUALCHECK conditional
    (50) conditional -> conditional . LESSTHAN conditional
    (51) conditional -> conditional . GREATERTHAN conditional
    (52) conditional -> conditional . ANDOPERATOR conditional
    (53) conditional -> conditional . OROPERATOR conditional

    UNEQUAL         reduce using rule 48 (conditional -> conditional UNEQUAL conditional .)
    EQUALCHECK      reduce using rule 48 (conditional -> conditional UNEQUAL conditional .)
    ANDOPERATOR     reduce using rule 48 (conditional -> conditional UNEQUAL conditional .)
    OROPERATOR      reduce using rule 48 (conditional -> conditional UNEQUAL conditional .)
    RPAREN          reduce using rule 48 (conditional -> conditional UNEQUAL conditional .)
    LESSTHANEQ      shift and go to state 118
    GREATERTHANEQ   shift and go to state 116
    LESSTHAN        shift and go to state 113
    GREATERTHAN     shift and go to state 112

  ! LESSTHANEQ      [ reduce using rule 48 (conditional -> conditional UNEQUAL conditional .) ]
  ! GREATERTHANEQ   [ reduce using rule 48 (conditional -> conditional UNEQUAL conditional .) ]
  ! LESSTHAN        [ reduce using rule 48 (conditional -> conditional UNEQUAL conditional .) ]
  ! GREATERTHAN     [ reduce using rule 48 (conditional -> conditional UNEQUAL conditional .) ]
  ! UNEQUAL         [ shift and go to state 117 ]
  ! EQUALCHECK      [ shift and go to state 119 ]
  ! ANDOPERATOR     [ shift and go to state 115 ]
  ! OROPERATOR      [ shift and go to state 114 ]


state 140

    (46) conditional -> conditional LESSTHANEQ conditional .
    (46) conditional -> conditional . LESSTHANEQ conditional
    (47) conditional -> conditional . GREATERTHANEQ conditional
    (48) conditional -> conditional . UNEQUAL conditional
    (49) conditional -> conditional . EQUALCHECK conditional
    (50) conditional -> conditional . LESSTHAN conditional
    (51) conditional -> conditional . GREATERTHAN conditional
    (52) conditional -> conditional . ANDOPERATOR conditional
    (53) conditional -> conditional . OROPERATOR conditional

    LESSTHANEQ      reduce using rule 46 (conditional -> conditional LESSTHANEQ conditional .)
    GREATERTHANEQ   reduce using rule 46 (conditional -> conditional LESSTHANEQ conditional .)
    UNEQUAL         reduce using rule 46 (conditional -> conditional LESSTHANEQ conditional .)
    EQUALCHECK      reduce using rule 46 (conditional -> conditional LESSTHANEQ conditional .)
    LESSTHAN        reduce using rule 46 (conditional -> conditional LESSTHANEQ conditional .)
    GREATERTHAN     reduce using rule 46 (conditional -> conditional LESSTHANEQ conditional .)
    ANDOPERATOR     reduce using rule 46 (conditional -> conditional LESSTHANEQ conditional .)
    OROPERATOR      reduce using rule 46 (conditional -> conditional LESSTHANEQ conditional .)
    RPAREN          reduce using rule 46 (conditional -> conditional LESSTHANEQ conditional .)

  ! LESSTHANEQ      [ shift and go to state 118 ]
  ! GREATERTHANEQ   [ shift and go to state 116 ]
  ! UNEQUAL         [ shift and go to state 117 ]
  ! EQUALCHECK      [ shift and go to state 119 ]
  ! LESSTHAN        [ shift and go to state 113 ]
  ! GREATERTHAN     [ shift and go to state 112 ]
  ! ANDOPERATOR     [ shift and go to state 115 ]
  ! OROPERATOR      [ shift and go to state 114 ]


state 141

    (49) conditional -> conditional EQUALCHECK conditional .
    (46) conditional -> conditional . LESSTHANEQ conditional
    (47) conditional -> conditional . GREATERTHANEQ conditional
    (48) conditional -> conditional . UNEQUAL conditional
    (49) conditional -> conditional . EQUALCHECK conditional
    (50) conditional -> conditional . LESSTHAN conditional
    (51) conditional -> conditional . GREATERTHAN conditional
    (52) conditional -> conditional . ANDOPERATOR conditional
    (53) conditional -> conditional . OROPERATOR conditional

    UNEQUAL         reduce using rule 49 (conditional -> conditional EQUALCHECK conditional .)
    EQUALCHECK      reduce using rule 49 (conditional -> conditional EQUALCHECK conditional .)
    ANDOPERATOR     reduce using rule 49 (conditional -> conditional EQUALCHECK conditional .)
    OROPERATOR      reduce using rule 49 (conditional -> conditional EQUALCHECK conditional .)
    RPAREN          reduce using rule 49 (conditional -> conditional EQUALCHECK conditional .)
    LESSTHANEQ      shift and go to state 118
    GREATERTHANEQ   shift and go to state 116
    LESSTHAN        shift and go to state 113
    GREATERTHAN     shift and go to state 112

  ! LESSTHANEQ      [ reduce using rule 49 (conditional -> conditional EQUALCHECK conditional .) ]
  ! GREATERTHANEQ   [ reduce using rule 49 (conditional -> conditional EQUALCHECK conditional .) ]
  ! LESSTHAN        [ reduce using rule 49 (conditional -> conditional EQUALCHECK conditional .) ]
  ! GREATERTHAN     [ reduce using rule 49 (conditional -> conditional EQUALCHECK conditional .) ]
  ! UNEQUAL         [ shift and go to state 117 ]
  ! EQUALCHECK      [ shift and go to state 119 ]
  ! ANDOPERATOR     [ shift and go to state 115 ]
  ! OROPERATOR      [ shift and go to state 114 ]


state 142

    (43) conditional -> LPAREN conditional RPAREN .

    LESSTHANEQ      reduce using rule 43 (conditional -> LPAREN conditional RPAREN .)
    GREATERTHANEQ   reduce using rule 43 (conditional -> LPAREN conditional RPAREN .)
    UNEQUAL         reduce using rule 43 (conditional -> LPAREN conditional RPAREN .)
    EQUALCHECK      reduce using rule 43 (conditional -> LPAREN conditional RPAREN .)
    LESSTHAN        reduce using rule 43 (conditional -> LPAREN conditional RPAREN .)
    GREATERTHAN     reduce using rule 43 (conditional -> LPAREN conditional RPAREN .)
    ANDOPERATOR     reduce using rule 43 (conditional -> LPAREN conditional RPAREN .)
    OROPERATOR      reduce using rule 43 (conditional -> LPAREN conditional RPAREN .)
    RPAREN          reduce using rule 43 (conditional -> LPAREN conditional RPAREN .)


state 143

    (61) CS -> NOT . LPAREN expression RPAREN

    LPAREN          shift and go to state 157


state 144

    (56) conditionbase -> CS UNEQUAL CS .

    RPAREN          reduce using rule 56 (conditionbase -> CS UNEQUAL CS .)
    LESSTHANEQ      reduce using rule 56 (conditionbase -> CS UNEQUAL CS .)
    GREATERTHANEQ   reduce using rule 56 (conditionbase -> CS UNEQUAL CS .)
    UNEQUAL         reduce using rule 56 (conditionbase -> CS UNEQUAL CS .)
    EQUALCHECK      reduce using rule 56 (conditionbase -> CS UNEQUAL CS .)
    LESSTHAN        reduce using rule 56 (conditionbase -> CS UNEQUAL CS .)
    GREATERTHAN     reduce using rule 56 (conditionbase -> CS UNEQUAL CS .)
    ANDOPERATOR     reduce using rule 56 (conditionbase -> CS UNEQUAL CS .)
    OROPERATOR      reduce using rule 56 (conditionbase -> CS UNEQUAL CS .)


state 145

    (58) conditionbase -> CS LESSTHAN CS .

    RPAREN          reduce using rule 58 (conditionbase -> CS LESSTHAN CS .)
    LESSTHANEQ      reduce using rule 58 (conditionbase -> CS LESSTHAN CS .)
    GREATERTHANEQ   reduce using rule 58 (conditionbase -> CS LESSTHAN CS .)
    UNEQUAL         reduce using rule 58 (conditionbase -> CS LESSTHAN CS .)
    EQUALCHECK      reduce using rule 58 (conditionbase -> CS LESSTHAN CS .)
    LESSTHAN        reduce using rule 58 (conditionbase -> CS LESSTHAN CS .)
    GREATERTHAN     reduce using rule 58 (conditionbase -> CS LESSTHAN CS .)
    ANDOPERATOR     reduce using rule 58 (conditionbase -> CS LESSTHAN CS .)
    OROPERATOR      reduce using rule 58 (conditionbase -> CS LESSTHAN CS .)


state 146

    (55) conditionbase -> CS GREATERTHANEQ CS .

    RPAREN          reduce using rule 55 (conditionbase -> CS GREATERTHANEQ CS .)
    LESSTHANEQ      reduce using rule 55 (conditionbase -> CS GREATERTHANEQ CS .)
    GREATERTHANEQ   reduce using rule 55 (conditionbase -> CS GREATERTHANEQ CS .)
    UNEQUAL         reduce using rule 55 (conditionbase -> CS GREATERTHANEQ CS .)
    EQUALCHECK      reduce using rule 55 (conditionbase -> CS GREATERTHANEQ CS .)
    LESSTHAN        reduce using rule 55 (conditionbase -> CS GREATERTHANEQ CS .)
    GREATERTHAN     reduce using rule 55 (conditionbase -> CS GREATERTHANEQ CS .)
    ANDOPERATOR     reduce using rule 55 (conditionbase -> CS GREATERTHANEQ CS .)
    OROPERATOR      reduce using rule 55 (conditionbase -> CS GREATERTHANEQ CS .)


state 147

    (59) conditionbase -> CS GREATERTHAN CS .

    RPAREN          reduce using rule 59 (conditionbase -> CS GREATERTHAN CS .)
    LESSTHANEQ      reduce using rule 59 (conditionbase -> CS GREATERTHAN CS .)
    GREATERTHANEQ   reduce using rule 59 (conditionbase -> CS GREATERTHAN CS .)
    UNEQUAL         reduce using rule 59 (conditionbase -> CS GREATERTHAN CS .)
    EQUALCHECK      reduce using rule 59 (conditionbase -> CS GREATERTHAN CS .)
    LESSTHAN        reduce using rule 59 (conditionbase -> CS GREATERTHAN CS .)
    GREATERTHAN     reduce using rule 59 (conditionbase -> CS GREATERTHAN CS .)
    ANDOPERATOR     reduce using rule 59 (conditionbase -> CS GREATERTHAN CS .)
    OROPERATOR      reduce using rule 59 (conditionbase -> CS GREATERTHAN CS .)


state 148

    (54) conditionbase -> CS LESSTHANEQ CS .

    RPAREN          reduce using rule 54 (conditionbase -> CS LESSTHANEQ CS .)
    LESSTHANEQ      reduce using rule 54 (conditionbase -> CS LESSTHANEQ CS .)
    GREATERTHANEQ   reduce using rule 54 (conditionbase -> CS LESSTHANEQ CS .)
    UNEQUAL         reduce using rule 54 (conditionbase -> CS LESSTHANEQ CS .)
    EQUALCHECK      reduce using rule 54 (conditionbase -> CS LESSTHANEQ CS .)
    LESSTHAN        reduce using rule 54 (conditionbase -> CS LESSTHANEQ CS .)
    GREATERTHAN     reduce using rule 54 (conditionbase -> CS LESSTHANEQ CS .)
    ANDOPERATOR     reduce using rule 54 (conditionbase -> CS LESSTHANEQ CS .)
    OROPERATOR      reduce using rule 54 (conditionbase -> CS LESSTHANEQ CS .)


state 149

    (57) conditionbase -> CS EQUALCHECK CS .

    RPAREN          reduce using rule 57 (conditionbase -> CS EQUALCHECK CS .)
    LESSTHANEQ      reduce using rule 57 (conditionbase -> CS EQUALCHECK CS .)
    GREATERTHANEQ   reduce using rule 57 (conditionbase -> CS EQUALCHECK CS .)
    UNEQUAL         reduce using rule 57 (conditionbase -> CS EQUALCHECK CS .)
    EQUALCHECK      reduce using rule 57 (conditionbase -> CS EQUALCHECK CS .)
    LESSTHAN        reduce using rule 57 (conditionbase -> CS EQUALCHECK CS .)
    GREATERTHAN     reduce using rule 57 (conditionbase -> CS EQUALCHECK CS .)
    ANDOPERATOR     reduce using rule 57 (conditionbase -> CS EQUALCHECK CS .)
    OROPERATOR      reduce using rule 57 (conditionbase -> CS EQUALCHECK CS .)


state 150

    (45) conditional -> NOT LPAREN conditional . RPAREN
    (46) conditional -> conditional . LESSTHANEQ conditional
    (47) conditional -> conditional . GREATERTHANEQ conditional
    (48) conditional -> conditional . UNEQUAL conditional
    (49) conditional -> conditional . EQUALCHECK conditional
    (50) conditional -> conditional . LESSTHAN conditional
    (51) conditional -> conditional . GREATERTHAN conditional
    (52) conditional -> conditional . ANDOPERATOR conditional
    (53) conditional -> conditional . OROPERATOR conditional

    RPAREN          shift and go to state 158
    LESSTHANEQ      shift and go to state 118
    GREATERTHANEQ   shift and go to state 116
    UNEQUAL         shift and go to state 117
    EQUALCHECK      shift and go to state 119
    LESSTHAN        shift and go to state 113
    GREATERTHAN     shift and go to state 112
    ANDOPERATOR     shift and go to state 115
    OROPERATOR      shift and go to state 114


state 151

    (61) CS -> NOT LPAREN expression . RPAREN
    (73) expression -> expression . PLUS expression
    (74) expression -> expression . MINUS expression
    (75) expression -> expression . DIVIDE expression
    (76) expression -> expression . TIMES expression
    (60) CS -> expression .

    RPAREN          shift and go to state 159
    PLUS            shift and go to state 90
    MINUS           shift and go to state 91
    DIVIDE          shift and go to state 87
    TIMES           shift and go to state 89
    LESSTHANEQ      reduce using rule 60 (CS -> expression .)
    GREATERTHANEQ   reduce using rule 60 (CS -> expression .)
    UNEQUAL         reduce using rule 60 (CS -> expression .)
    EQUALCHECK      reduce using rule 60 (CS -> expression .)
    LESSTHAN        reduce using rule 60 (CS -> expression .)
    GREATERTHAN     reduce using rule 60 (CS -> expression .)


state 152

    (35) unmatchedstatement -> IF LPAREN conditional RPAREN statement . ELSE unmatchedstatement
    (38) ifblock -> IF LPAREN conditional RPAREN statement . ELSE statement
    (39) ifblock -> IF LPAREN conditional RPAREN statement . ELSE LBRACE fbody RBRACE
    (20) allstatement -> statement .

    ELSE            shift and go to state 160
    SEMICOLON       reduce using rule 20 (allstatement -> statement .)
    IF              reduce using rule 20 (allstatement -> statement .)
    TYPE            reduce using rule 20 (allstatement -> statement .)
    WHILE           reduce using rule 20 (allstatement -> statement .)
    RETURN          reduce using rule 20 (allstatement -> statement .)
    NAME            reduce using rule 20 (allstatement -> statement .)
    TIMES           reduce using rule 20 (allstatement -> statement .)
    RBRACE          reduce using rule 20 (allstatement -> statement .)


state 153

    (36) unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE . fbody RBRACE ELSE unmatchedstatement
    (37) unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE . fbody RBRACE
    (40) ifblock -> IF LPAREN conditional RPAREN LBRACE . fbody RBRACE ELSE LBRACE fbody RBRACE
    (41) ifblock -> IF LPAREN conditional RPAREN LBRACE . fbody RBRACE ELSE statement
    (18) fbody -> . allstatement fbody
    (19) fbody -> .
    (20) allstatement -> . statement
    (21) allstatement -> . unmatchedstatement
    (22) statement -> . assignment
    (23) statement -> . declaration
    (24) statement -> . whileblock
    (25) statement -> . ifblock
    (26) statement -> . returnstatement
    (27) statement -> . functioncall SEMICOLON
    (33) statement -> . SEMICOLON
    (34) unmatchedstatement -> . IF LPAREN conditional RPAREN allstatement
    (35) unmatchedstatement -> . IF LPAREN conditional RPAREN statement ELSE unmatchedstatement
    (36) unmatchedstatement -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE unmatchedstatement
    (37) unmatchedstatement -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE
    (69) assignment -> . assignment_base SEMICOLON
    (62) declaration -> . TYPE dlist1 SEMICOLON
    (42) whileblock -> . WHILE LPAREN conditional RPAREN LBRACE fbody RBRACE
    (38) ifblock -> . IF LPAREN conditional RPAREN statement ELSE statement
    (39) ifblock -> . IF LPAREN conditional RPAREN statement ELSE LBRACE fbody RBRACE
    (40) ifblock -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE
    (41) ifblock -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE statement
    (28) returnstatement -> . RETURN expression SEMICOLON
    (29) returnstatement -> . RETURN SEMICOLON
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (70) assignment_base -> . TIMES pointervar EQUALS expression
    (71) assignment_base -> . NAME EQUALS expression

    RBRACE          reduce using rule 19 (fbody -> .)
    SEMICOLON       shift and go to state 42
    IF              shift and go to state 52
    TYPE            shift and go to state 56
    WHILE           shift and go to state 40
    RETURN          shift and go to state 39
    NAME            shift and go to state 53
    TIMES           shift and go to state 50

    unmatchedstatement             shift and go to state 41
    declaration                    shift and go to state 49
    assignment                     shift and go to state 48
    whileblock                     shift and go to state 43
    ifblock                        shift and go to state 44
    allstatement                   shift and go to state 54
    statement                      shift and go to state 45
    fbody                          shift and go to state 161
    functioncall                   shift and go to state 46
    returnstatement                shift and go to state 55
    assignment_base                shift and go to state 47

state 154

    (34) unmatchedstatement -> IF LPAREN conditional RPAREN allstatement .

    SEMICOLON       reduce using rule 34 (unmatchedstatement -> IF LPAREN conditional RPAREN allstatement .)
    IF              reduce using rule 34 (unmatchedstatement -> IF LPAREN conditional RPAREN allstatement .)
    TYPE            reduce using rule 34 (unmatchedstatement -> IF LPAREN conditional RPAREN allstatement .)
    WHILE           reduce using rule 34 (unmatchedstatement -> IF LPAREN conditional RPAREN allstatement .)
    RETURN          reduce using rule 34 (unmatchedstatement -> IF LPAREN conditional RPAREN allstatement .)
    NAME            reduce using rule 34 (unmatchedstatement -> IF LPAREN conditional RPAREN allstatement .)
    TIMES           reduce using rule 34 (unmatchedstatement -> IF LPAREN conditional RPAREN allstatement .)
    RBRACE          reduce using rule 34 (unmatchedstatement -> IF LPAREN conditional RPAREN allstatement .)


state 155

    (32) arguments -> expression COMMA arguments .

    RPAREN          reduce using rule 32 (arguments -> expression COMMA arguments .)


state 156

    (42) whileblock -> WHILE LPAREN conditional RPAREN LBRACE fbody . RBRACE

    RBRACE          shift and go to state 162


state 157

    (61) CS -> NOT LPAREN . expression RPAREN
    (72) expression -> . functioncall
    (73) expression -> . expression PLUS expression
    (74) expression -> . expression MINUS expression
    (75) expression -> . expression DIVIDE expression
    (76) expression -> . expression TIMES expression
    (77) expression -> . MINUS expression
    (78) expression -> . LPAREN expression RPAREN
    (79) expression -> . allnumbers
    (82) expression -> . pointervar
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (80) allnumbers -> . FLOAT
    (81) allnumbers -> . NUMBER
    (83) pointervar -> . TIMES pointervar
    (84) pointervar -> . ADDROF pointervar
    (85) pointervar -> . NAME

    MINUS           shift and go to state 70
    LPAREN          shift and go to state 68
    NAME            shift and go to state 61
    FLOAT           shift and go to state 59
    NUMBER          shift and go to state 65
    TIMES           shift and go to state 66
    ADDROF          shift and go to state 62

    functioncall                   shift and go to state 67
    pointervar                     shift and go to state 64
    allnumbers                     shift and go to state 63
    expression                     shift and go to state 163

state 158

    (45) conditional -> NOT LPAREN conditional RPAREN .

    LESSTHANEQ      reduce using rule 45 (conditional -> NOT LPAREN conditional RPAREN .)
    GREATERTHANEQ   reduce using rule 45 (conditional -> NOT LPAREN conditional RPAREN .)
    UNEQUAL         reduce using rule 45 (conditional -> NOT LPAREN conditional RPAREN .)
    EQUALCHECK      reduce using rule 45 (conditional -> NOT LPAREN conditional RPAREN .)
    LESSTHAN        reduce using rule 45 (conditional -> NOT LPAREN conditional RPAREN .)
    GREATERTHAN     reduce using rule 45 (conditional -> NOT LPAREN conditional RPAREN .)
    ANDOPERATOR     reduce using rule 45 (conditional -> NOT LPAREN conditional RPAREN .)
    OROPERATOR      reduce using rule 45 (conditional -> NOT LPAREN conditional RPAREN .)
    RPAREN          reduce using rule 45 (conditional -> NOT LPAREN conditional RPAREN .)


state 159

    (61) CS -> NOT LPAREN expression RPAREN .

    LESSTHANEQ      reduce using rule 61 (CS -> NOT LPAREN expression RPAREN .)
    GREATERTHANEQ   reduce using rule 61 (CS -> NOT LPAREN expression RPAREN .)
    UNEQUAL         reduce using rule 61 (CS -> NOT LPAREN expression RPAREN .)
    EQUALCHECK      reduce using rule 61 (CS -> NOT LPAREN expression RPAREN .)
    LESSTHAN        reduce using rule 61 (CS -> NOT LPAREN expression RPAREN .)
    GREATERTHAN     reduce using rule 61 (CS -> NOT LPAREN expression RPAREN .)
    RPAREN          reduce using rule 61 (CS -> NOT LPAREN expression RPAREN .)
    ANDOPERATOR     reduce using rule 61 (CS -> NOT LPAREN expression RPAREN .)
    OROPERATOR      reduce using rule 61 (CS -> NOT LPAREN expression RPAREN .)


state 160

    (35) unmatchedstatement -> IF LPAREN conditional RPAREN statement ELSE . unmatchedstatement
    (38) ifblock -> IF LPAREN conditional RPAREN statement ELSE . statement
    (39) ifblock -> IF LPAREN conditional RPAREN statement ELSE . LBRACE fbody RBRACE
    (34) unmatchedstatement -> . IF LPAREN conditional RPAREN allstatement
    (35) unmatchedstatement -> . IF LPAREN conditional RPAREN statement ELSE unmatchedstatement
    (36) unmatchedstatement -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE unmatchedstatement
    (37) unmatchedstatement -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE
    (22) statement -> . assignment
    (23) statement -> . declaration
    (24) statement -> . whileblock
    (25) statement -> . ifblock
    (26) statement -> . returnstatement
    (27) statement -> . functioncall SEMICOLON
    (33) statement -> . SEMICOLON
    (69) assignment -> . assignment_base SEMICOLON
    (62) declaration -> . TYPE dlist1 SEMICOLON
    (42) whileblock -> . WHILE LPAREN conditional RPAREN LBRACE fbody RBRACE
    (38) ifblock -> . IF LPAREN conditional RPAREN statement ELSE statement
    (39) ifblock -> . IF LPAREN conditional RPAREN statement ELSE LBRACE fbody RBRACE
    (40) ifblock -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE
    (41) ifblock -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE statement
    (28) returnstatement -> . RETURN expression SEMICOLON
    (29) returnstatement -> . RETURN SEMICOLON
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (70) assignment_base -> . TIMES pointervar EQUALS expression
    (71) assignment_base -> . NAME EQUALS expression

    LBRACE          shift and go to state 166
    IF              shift and go to state 52
    SEMICOLON       shift and go to state 42
    TYPE            shift and go to state 56
    WHILE           shift and go to state 40
    RETURN          shift and go to state 39
    NAME            shift and go to state 53
    TIMES           shift and go to state 50

    unmatchedstatement             shift and go to state 164
    declaration                    shift and go to state 49
    assignment                     shift and go to state 48
    whileblock                     shift and go to state 43
    ifblock                        shift and go to state 44
    statement                      shift and go to state 165
    functioncall                   shift and go to state 46
    returnstatement                shift and go to state 55
    assignment_base                shift and go to state 47

state 161

    (36) unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody . RBRACE ELSE unmatchedstatement
    (37) unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody . RBRACE
    (40) ifblock -> IF LPAREN conditional RPAREN LBRACE fbody . RBRACE ELSE LBRACE fbody RBRACE
    (41) ifblock -> IF LPAREN conditional RPAREN LBRACE fbody . RBRACE ELSE statement

    RBRACE          shift and go to state 167


state 162

    (42) whileblock -> WHILE LPAREN conditional RPAREN LBRACE fbody RBRACE .

    SEMICOLON       reduce using rule 42 (whileblock -> WHILE LPAREN conditional RPAREN LBRACE fbody RBRACE .)
    IF              reduce using rule 42 (whileblock -> WHILE LPAREN conditional RPAREN LBRACE fbody RBRACE .)
    TYPE            reduce using rule 42 (whileblock -> WHILE LPAREN conditional RPAREN LBRACE fbody RBRACE .)
    WHILE           reduce using rule 42 (whileblock -> WHILE LPAREN conditional RPAREN LBRACE fbody RBRACE .)
    RETURN          reduce using rule 42 (whileblock -> WHILE LPAREN conditional RPAREN LBRACE fbody RBRACE .)
    NAME            reduce using rule 42 (whileblock -> WHILE LPAREN conditional RPAREN LBRACE fbody RBRACE .)
    TIMES           reduce using rule 42 (whileblock -> WHILE LPAREN conditional RPAREN LBRACE fbody RBRACE .)
    RBRACE          reduce using rule 42 (whileblock -> WHILE LPAREN conditional RPAREN LBRACE fbody RBRACE .)
    ELSE            reduce using rule 42 (whileblock -> WHILE LPAREN conditional RPAREN LBRACE fbody RBRACE .)


state 163

    (61) CS -> NOT LPAREN expression . RPAREN
    (73) expression -> expression . PLUS expression
    (74) expression -> expression . MINUS expression
    (75) expression -> expression . DIVIDE expression
    (76) expression -> expression . TIMES expression

    RPAREN          shift and go to state 159
    PLUS            shift and go to state 90
    MINUS           shift and go to state 91
    DIVIDE          shift and go to state 87
    TIMES           shift and go to state 89


state 164

    (35) unmatchedstatement -> IF LPAREN conditional RPAREN statement ELSE unmatchedstatement .

    SEMICOLON       reduce using rule 35 (unmatchedstatement -> IF LPAREN conditional RPAREN statement ELSE unmatchedstatement .)
    IF              reduce using rule 35 (unmatchedstatement -> IF LPAREN conditional RPAREN statement ELSE unmatchedstatement .)
    TYPE            reduce using rule 35 (unmatchedstatement -> IF LPAREN conditional RPAREN statement ELSE unmatchedstatement .)
    WHILE           reduce using rule 35 (unmatchedstatement -> IF LPAREN conditional RPAREN statement ELSE unmatchedstatement .)
    RETURN          reduce using rule 35 (unmatchedstatement -> IF LPAREN conditional RPAREN statement ELSE unmatchedstatement .)
    NAME            reduce using rule 35 (unmatchedstatement -> IF LPAREN conditional RPAREN statement ELSE unmatchedstatement .)
    TIMES           reduce using rule 35 (unmatchedstatement -> IF LPAREN conditional RPAREN statement ELSE unmatchedstatement .)
    RBRACE          reduce using rule 35 (unmatchedstatement -> IF LPAREN conditional RPAREN statement ELSE unmatchedstatement .)


state 165

    (38) ifblock -> IF LPAREN conditional RPAREN statement ELSE statement .

    SEMICOLON       reduce using rule 38 (ifblock -> IF LPAREN conditional RPAREN statement ELSE statement .)
    IF              reduce using rule 38 (ifblock -> IF LPAREN conditional RPAREN statement ELSE statement .)
    TYPE            reduce using rule 38 (ifblock -> IF LPAREN conditional RPAREN statement ELSE statement .)
    WHILE           reduce using rule 38 (ifblock -> IF LPAREN conditional RPAREN statement ELSE statement .)
    RETURN          reduce using rule 38 (ifblock -> IF LPAREN conditional RPAREN statement ELSE statement .)
    NAME            reduce using rule 38 (ifblock -> IF LPAREN conditional RPAREN statement ELSE statement .)
    TIMES           reduce using rule 38 (ifblock -> IF LPAREN conditional RPAREN statement ELSE statement .)
    RBRACE          reduce using rule 38 (ifblock -> IF LPAREN conditional RPAREN statement ELSE statement .)
    ELSE            reduce using rule 38 (ifblock -> IF LPAREN conditional RPAREN statement ELSE statement .)


state 166

    (39) ifblock -> IF LPAREN conditional RPAREN statement ELSE LBRACE . fbody RBRACE
    (18) fbody -> . allstatement fbody
    (19) fbody -> .
    (20) allstatement -> . statement
    (21) allstatement -> . unmatchedstatement
    (22) statement -> . assignment
    (23) statement -> . declaration
    (24) statement -> . whileblock
    (25) statement -> . ifblock
    (26) statement -> . returnstatement
    (27) statement -> . functioncall SEMICOLON
    (33) statement -> . SEMICOLON
    (34) unmatchedstatement -> . IF LPAREN conditional RPAREN allstatement
    (35) unmatchedstatement -> . IF LPAREN conditional RPAREN statement ELSE unmatchedstatement
    (36) unmatchedstatement -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE unmatchedstatement
    (37) unmatchedstatement -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE
    (69) assignment -> . assignment_base SEMICOLON
    (62) declaration -> . TYPE dlist1 SEMICOLON
    (42) whileblock -> . WHILE LPAREN conditional RPAREN LBRACE fbody RBRACE
    (38) ifblock -> . IF LPAREN conditional RPAREN statement ELSE statement
    (39) ifblock -> . IF LPAREN conditional RPAREN statement ELSE LBRACE fbody RBRACE
    (40) ifblock -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE
    (41) ifblock -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE statement
    (28) returnstatement -> . RETURN expression SEMICOLON
    (29) returnstatement -> . RETURN SEMICOLON
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (70) assignment_base -> . TIMES pointervar EQUALS expression
    (71) assignment_base -> . NAME EQUALS expression

    RBRACE          reduce using rule 19 (fbody -> .)
    SEMICOLON       shift and go to state 42
    IF              shift and go to state 52
    TYPE            shift and go to state 56
    WHILE           shift and go to state 40
    RETURN          shift and go to state 39
    NAME            shift and go to state 53
    TIMES           shift and go to state 50

    unmatchedstatement             shift and go to state 41
    declaration                    shift and go to state 49
    assignment                     shift and go to state 48
    whileblock                     shift and go to state 43
    ifblock                        shift and go to state 44
    allstatement                   shift and go to state 54
    statement                      shift and go to state 45
    fbody                          shift and go to state 168
    functioncall                   shift and go to state 46
    returnstatement                shift and go to state 55
    assignment_base                shift and go to state 47

state 167

    (36) unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE . ELSE unmatchedstatement
    (37) unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE .
    (40) ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE . ELSE LBRACE fbody RBRACE
    (41) ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE . ELSE statement

    ELSE            shift and go to state 169
    SEMICOLON       reduce using rule 37 (unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE .)
    IF              reduce using rule 37 (unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE .)
    TYPE            reduce using rule 37 (unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE .)
    WHILE           reduce using rule 37 (unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE .)
    RETURN          reduce using rule 37 (unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE .)
    NAME            reduce using rule 37 (unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE .)
    TIMES           reduce using rule 37 (unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE .)
    RBRACE          reduce using rule 37 (unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE .)


state 168

    (39) ifblock -> IF LPAREN conditional RPAREN statement ELSE LBRACE fbody . RBRACE

    RBRACE          shift and go to state 170


state 169

    (36) unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE . unmatchedstatement
    (40) ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE . LBRACE fbody RBRACE
    (41) ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE . statement
    (34) unmatchedstatement -> . IF LPAREN conditional RPAREN allstatement
    (35) unmatchedstatement -> . IF LPAREN conditional RPAREN statement ELSE unmatchedstatement
    (36) unmatchedstatement -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE unmatchedstatement
    (37) unmatchedstatement -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE
    (22) statement -> . assignment
    (23) statement -> . declaration
    (24) statement -> . whileblock
    (25) statement -> . ifblock
    (26) statement -> . returnstatement
    (27) statement -> . functioncall SEMICOLON
    (33) statement -> . SEMICOLON
    (69) assignment -> . assignment_base SEMICOLON
    (62) declaration -> . TYPE dlist1 SEMICOLON
    (42) whileblock -> . WHILE LPAREN conditional RPAREN LBRACE fbody RBRACE
    (38) ifblock -> . IF LPAREN conditional RPAREN statement ELSE statement
    (39) ifblock -> . IF LPAREN conditional RPAREN statement ELSE LBRACE fbody RBRACE
    (40) ifblock -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE
    (41) ifblock -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE statement
    (28) returnstatement -> . RETURN expression SEMICOLON
    (29) returnstatement -> . RETURN SEMICOLON
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (70) assignment_base -> . TIMES pointervar EQUALS expression
    (71) assignment_base -> . NAME EQUALS expression

    LBRACE          shift and go to state 173
    IF              shift and go to state 52
    SEMICOLON       shift and go to state 42
    TYPE            shift and go to state 56
    WHILE           shift and go to state 40
    RETURN          shift and go to state 39
    NAME            shift and go to state 53
    TIMES           shift and go to state 50

    unmatchedstatement             shift and go to state 171
    declaration                    shift and go to state 49
    assignment                     shift and go to state 48
    whileblock                     shift and go to state 43
    ifblock                        shift and go to state 44
    statement                      shift and go to state 172
    functioncall                   shift and go to state 46
    returnstatement                shift and go to state 55
    assignment_base                shift and go to state 47

state 170

    (39) ifblock -> IF LPAREN conditional RPAREN statement ELSE LBRACE fbody RBRACE .

    SEMICOLON       reduce using rule 39 (ifblock -> IF LPAREN conditional RPAREN statement ELSE LBRACE fbody RBRACE .)
    IF              reduce using rule 39 (ifblock -> IF LPAREN conditional RPAREN statement ELSE LBRACE fbody RBRACE .)
    TYPE            reduce using rule 39 (ifblock -> IF LPAREN conditional RPAREN statement ELSE LBRACE fbody RBRACE .)
    WHILE           reduce using rule 39 (ifblock -> IF LPAREN conditional RPAREN statement ELSE LBRACE fbody RBRACE .)
    RETURN          reduce using rule 39 (ifblock -> IF LPAREN conditional RPAREN statement ELSE LBRACE fbody RBRACE .)
    NAME            reduce using rule 39 (ifblock -> IF LPAREN conditional RPAREN statement ELSE LBRACE fbody RBRACE .)
    TIMES           reduce using rule 39 (ifblock -> IF LPAREN conditional RPAREN statement ELSE LBRACE fbody RBRACE .)
    RBRACE          reduce using rule 39 (ifblock -> IF LPAREN conditional RPAREN statement ELSE LBRACE fbody RBRACE .)
    ELSE            reduce using rule 39 (ifblock -> IF LPAREN conditional RPAREN statement ELSE LBRACE fbody RBRACE .)


state 171

    (36) unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE unmatchedstatement .

    SEMICOLON       reduce using rule 36 (unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE unmatchedstatement .)
    IF              reduce using rule 36 (unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE unmatchedstatement .)
    TYPE            reduce using rule 36 (unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE unmatchedstatement .)
    WHILE           reduce using rule 36 (unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE unmatchedstatement .)
    RETURN          reduce using rule 36 (unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE unmatchedstatement .)
    NAME            reduce using rule 36 (unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE unmatchedstatement .)
    TIMES           reduce using rule 36 (unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE unmatchedstatement .)
    RBRACE          reduce using rule 36 (unmatchedstatement -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE unmatchedstatement .)


state 172

    (41) ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE statement .

    SEMICOLON       reduce using rule 41 (ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE statement .)
    IF              reduce using rule 41 (ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE statement .)
    TYPE            reduce using rule 41 (ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE statement .)
    WHILE           reduce using rule 41 (ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE statement .)
    RETURN          reduce using rule 41 (ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE statement .)
    NAME            reduce using rule 41 (ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE statement .)
    TIMES           reduce using rule 41 (ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE statement .)
    RBRACE          reduce using rule 41 (ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE statement .)
    ELSE            reduce using rule 41 (ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE statement .)


state 173

    (40) ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE . fbody RBRACE
    (18) fbody -> . allstatement fbody
    (19) fbody -> .
    (20) allstatement -> . statement
    (21) allstatement -> . unmatchedstatement
    (22) statement -> . assignment
    (23) statement -> . declaration
    (24) statement -> . whileblock
    (25) statement -> . ifblock
    (26) statement -> . returnstatement
    (27) statement -> . functioncall SEMICOLON
    (33) statement -> . SEMICOLON
    (34) unmatchedstatement -> . IF LPAREN conditional RPAREN allstatement
    (35) unmatchedstatement -> . IF LPAREN conditional RPAREN statement ELSE unmatchedstatement
    (36) unmatchedstatement -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE unmatchedstatement
    (37) unmatchedstatement -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE
    (69) assignment -> . assignment_base SEMICOLON
    (62) declaration -> . TYPE dlist1 SEMICOLON
    (42) whileblock -> . WHILE LPAREN conditional RPAREN LBRACE fbody RBRACE
    (38) ifblock -> . IF LPAREN conditional RPAREN statement ELSE statement
    (39) ifblock -> . IF LPAREN conditional RPAREN statement ELSE LBRACE fbody RBRACE
    (40) ifblock -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE
    (41) ifblock -> . IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE statement
    (28) returnstatement -> . RETURN expression SEMICOLON
    (29) returnstatement -> . RETURN SEMICOLON
    (30) functioncall -> . NAME LPAREN arguments RPAREN
    (70) assignment_base -> . TIMES pointervar EQUALS expression
    (71) assignment_base -> . NAME EQUALS expression

    RBRACE          reduce using rule 19 (fbody -> .)
    SEMICOLON       shift and go to state 42
    IF              shift and go to state 52
    TYPE            shift and go to state 56
    WHILE           shift and go to state 40
    RETURN          shift and go to state 39
    NAME            shift and go to state 53
    TIMES           shift and go to state 50

    unmatchedstatement             shift and go to state 41
    declaration                    shift and go to state 49
    assignment                     shift and go to state 48
    whileblock                     shift and go to state 43
    ifblock                        shift and go to state 44
    allstatement                   shift and go to state 54
    statement                      shift and go to state 45
    fbody                          shift and go to state 174
    functioncall                   shift and go to state 46
    returnstatement                shift and go to state 55
    assignment_base                shift and go to state 47

state 174

    (40) ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody . RBRACE

    RBRACE          shift and go to state 175


state 175

    (40) ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE .

    SEMICOLON       reduce using rule 40 (ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE .)
    IF              reduce using rule 40 (ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE .)
    TYPE            reduce using rule 40 (ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE .)
    WHILE           reduce using rule 40 (ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE .)
    RETURN          reduce using rule 40 (ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE .)
    NAME            reduce using rule 40 (ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE .)
    TIMES           reduce using rule 40 (ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE .)
    RBRACE          reduce using rule 40 (ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE .)
    ELSE            reduce using rule 40 (ifblock -> IF LPAREN conditional RPAREN LBRACE fbody RBRACE ELSE LBRACE fbody RBRACE .)

