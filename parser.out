Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    newline
    COMMENT
    TIMES

Grammar

Rule 0     S' -> program
Rule 1     program -> function
Rule 2     program -> function program
Rule 3     function -> TYPE NAME LPAREN RPAREN LBRACE fbody RBRACE
Rule 4     fbody -> statement
Rule 5     fbody -> statement fbody
Rule 6     statement -> assignment
Rule 7     statement -> declaration
Rule 8     declaration -> TYPE dlist1 SEMICOLON
Rule 9     dlist1 -> NAME
Rule 10    dlist1 -> NAME COMMA dlist1
Rule 11    dlist1 -> specialvar
Rule 12    dlist1 -> specialvar COMMA dlist1
Rule 13    specialvar -> VALOF specialvar
Rule 14    specialvar -> VALOF NAME
Rule 15    assignment -> assignment_base SEMICOLON
Rule 16    assignment_base -> VALOF pointervar EQUALS expression
Rule 17    assignment_base -> NAME EQUALS expression
Rule 18    expression -> expression PLUS expression
Rule 19    expression -> expression MINUS expression
Rule 20    expression -> expression VALOF expression
Rule 21    expression -> expression DIVIDE expression
Rule 22    expression -> MINUS expression
Rule 23    expression -> LPAREN expression RPAREN
Rule 24    expression -> NUMBER
Rule 25    expression -> pointervar
Rule 26    pointervar -> VALOF pointervar
Rule 27    pointervar -> ADDROF pointervar
Rule 28    pointervar -> NAME

Terminals, with rules where they appear

ADDROF               : 27
COMMA                : 10 12
COMMENT              : 
DIVIDE               : 21
EQUALS               : 16 17
LBRACE               : 3
LPAREN               : 3 23
MINUS                : 19 22
NAME                 : 3 9 10 14 17 28
NUMBER               : 24
PLUS                 : 18
RBRACE               : 3
RPAREN               : 3 23
SEMICOLON            : 8 15
TIMES                : 
TYPE                 : 3 8
VALOF                : 13 14 16 20 26
error                : 
newline              : 

Nonterminals, with rules where they appear

assignment           : 6
assignment_base      : 15
declaration          : 7
dlist1               : 8 10 12
expression           : 16 17 18 18 19 19 20 20 21 21 22 23
fbody                : 3 5
function             : 1 2
pointervar           : 16 25 26 27
program              : 2 0
specialvar           : 11 12 13
statement            : 4 5

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . function
    (2) program -> . function program
    (3) function -> . TYPE NAME LPAREN RPAREN LBRACE fbody RBRACE

    TYPE            shift and go to state 3

    program                        shift and go to state 1
    function                       shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> function .
    (2) program -> function . program
    (1) program -> . function
    (2) program -> . function program
    (3) function -> . TYPE NAME LPAREN RPAREN LBRACE fbody RBRACE

    $end            reduce using rule 1 (program -> function .)
    TYPE            shift and go to state 3

    function                       shift and go to state 2
    program                        shift and go to state 4

state 3

    (3) function -> TYPE . NAME LPAREN RPAREN LBRACE fbody RBRACE

    NAME            shift and go to state 5


state 4

    (2) program -> function program .

    $end            reduce using rule 2 (program -> function program .)


state 5

    (3) function -> TYPE NAME . LPAREN RPAREN LBRACE fbody RBRACE

    LPAREN          shift and go to state 6


state 6

    (3) function -> TYPE NAME LPAREN . RPAREN LBRACE fbody RBRACE

    RPAREN          shift and go to state 7


state 7

    (3) function -> TYPE NAME LPAREN RPAREN . LBRACE fbody RBRACE

    LBRACE          shift and go to state 8


state 8

    (3) function -> TYPE NAME LPAREN RPAREN LBRACE . fbody RBRACE
    (4) fbody -> . statement
    (5) fbody -> . statement fbody
    (6) statement -> . assignment
    (7) statement -> . declaration
    (15) assignment -> . assignment_base SEMICOLON
    (8) declaration -> . TYPE dlist1 SEMICOLON
    (16) assignment_base -> . VALOF pointervar EQUALS expression
    (17) assignment_base -> . NAME EQUALS expression

    TYPE            shift and go to state 9
    VALOF           shift and go to state 16
    NAME            shift and go to state 10

    fbody                          shift and go to state 11
    statement                      shift and go to state 12
    assignment                     shift and go to state 13
    declaration                    shift and go to state 14
    assignment_base                shift and go to state 15

state 9

    (8) declaration -> TYPE . dlist1 SEMICOLON
    (9) dlist1 -> . NAME
    (10) dlist1 -> . NAME COMMA dlist1
    (11) dlist1 -> . specialvar
    (12) dlist1 -> . specialvar COMMA dlist1
    (13) specialvar -> . VALOF specialvar
    (14) specialvar -> . VALOF NAME

    NAME            shift and go to state 18
    VALOF           shift and go to state 20

    dlist1                         shift and go to state 17
    specialvar                     shift and go to state 19

state 10

    (17) assignment_base -> NAME . EQUALS expression

    EQUALS          shift and go to state 21


state 11

    (3) function -> TYPE NAME LPAREN RPAREN LBRACE fbody . RBRACE

    RBRACE          shift and go to state 22


state 12

    (4) fbody -> statement .
    (5) fbody -> statement . fbody
    (4) fbody -> . statement
    (5) fbody -> . statement fbody
    (6) statement -> . assignment
    (7) statement -> . declaration
    (15) assignment -> . assignment_base SEMICOLON
    (8) declaration -> . TYPE dlist1 SEMICOLON
    (16) assignment_base -> . VALOF pointervar EQUALS expression
    (17) assignment_base -> . NAME EQUALS expression

    RBRACE          reduce using rule 4 (fbody -> statement .)
    TYPE            shift and go to state 9
    VALOF           shift and go to state 16
    NAME            shift and go to state 10

    statement                      shift and go to state 12
    fbody                          shift and go to state 23
    assignment                     shift and go to state 13
    declaration                    shift and go to state 14
    assignment_base                shift and go to state 15

state 13

    (6) statement -> assignment .

    TYPE            reduce using rule 6 (statement -> assignment .)
    VALOF           reduce using rule 6 (statement -> assignment .)
    NAME            reduce using rule 6 (statement -> assignment .)
    RBRACE          reduce using rule 6 (statement -> assignment .)


state 14

    (7) statement -> declaration .

    TYPE            reduce using rule 7 (statement -> declaration .)
    VALOF           reduce using rule 7 (statement -> declaration .)
    NAME            reduce using rule 7 (statement -> declaration .)
    RBRACE          reduce using rule 7 (statement -> declaration .)


state 15

    (15) assignment -> assignment_base . SEMICOLON

    SEMICOLON       shift and go to state 24


state 16

    (16) assignment_base -> VALOF . pointervar EQUALS expression
    (26) pointervar -> . VALOF pointervar
    (27) pointervar -> . ADDROF pointervar
    (28) pointervar -> . NAME

    VALOF           shift and go to state 25
    ADDROF          shift and go to state 27
    NAME            shift and go to state 28

    pointervar                     shift and go to state 26

state 17

    (8) declaration -> TYPE dlist1 . SEMICOLON

    SEMICOLON       shift and go to state 29


state 18

    (9) dlist1 -> NAME .
    (10) dlist1 -> NAME . COMMA dlist1

    SEMICOLON       reduce using rule 9 (dlist1 -> NAME .)
    COMMA           shift and go to state 30


state 19

    (11) dlist1 -> specialvar .
    (12) dlist1 -> specialvar . COMMA dlist1

    SEMICOLON       reduce using rule 11 (dlist1 -> specialvar .)
    COMMA           shift and go to state 31


state 20

    (13) specialvar -> VALOF . specialvar
    (14) specialvar -> VALOF . NAME
    (13) specialvar -> . VALOF specialvar
    (14) specialvar -> . VALOF NAME

    NAME            shift and go to state 33
    VALOF           shift and go to state 20

    specialvar                     shift and go to state 32

state 21

    (17) assignment_base -> NAME EQUALS . expression
    (18) expression -> . expression PLUS expression
    (19) expression -> . expression MINUS expression
    (20) expression -> . expression VALOF expression
    (21) expression -> . expression DIVIDE expression
    (22) expression -> . MINUS expression
    (23) expression -> . LPAREN expression RPAREN
    (24) expression -> . NUMBER
    (25) expression -> . pointervar
    (26) pointervar -> . VALOF pointervar
    (27) pointervar -> . ADDROF pointervar
    (28) pointervar -> . NAME

    MINUS           shift and go to state 35
    LPAREN          shift and go to state 36
    NUMBER          shift and go to state 37
    VALOF           shift and go to state 25
    ADDROF          shift and go to state 27
    NAME            shift and go to state 28

    expression                     shift and go to state 34
    pointervar                     shift and go to state 38

state 22

    (3) function -> TYPE NAME LPAREN RPAREN LBRACE fbody RBRACE .

    TYPE            reduce using rule 3 (function -> TYPE NAME LPAREN RPAREN LBRACE fbody RBRACE .)
    $end            reduce using rule 3 (function -> TYPE NAME LPAREN RPAREN LBRACE fbody RBRACE .)


state 23

    (5) fbody -> statement fbody .

    RBRACE          reduce using rule 5 (fbody -> statement fbody .)


state 24

    (15) assignment -> assignment_base SEMICOLON .

    TYPE            reduce using rule 15 (assignment -> assignment_base SEMICOLON .)
    VALOF           reduce using rule 15 (assignment -> assignment_base SEMICOLON .)
    NAME            reduce using rule 15 (assignment -> assignment_base SEMICOLON .)
    RBRACE          reduce using rule 15 (assignment -> assignment_base SEMICOLON .)


state 25

    (26) pointervar -> VALOF . pointervar
    (26) pointervar -> . VALOF pointervar
    (27) pointervar -> . ADDROF pointervar
    (28) pointervar -> . NAME

    VALOF           shift and go to state 25
    ADDROF          shift and go to state 27
    NAME            shift and go to state 28

    pointervar                     shift and go to state 39

state 26

    (16) assignment_base -> VALOF pointervar . EQUALS expression

    EQUALS          shift and go to state 40


state 27

    (27) pointervar -> ADDROF . pointervar
    (26) pointervar -> . VALOF pointervar
    (27) pointervar -> . ADDROF pointervar
    (28) pointervar -> . NAME

    VALOF           shift and go to state 25
    ADDROF          shift and go to state 27
    NAME            shift and go to state 28

    pointervar                     shift and go to state 41

state 28

    (28) pointervar -> NAME .

    EQUALS          reduce using rule 28 (pointervar -> NAME .)
    PLUS            reduce using rule 28 (pointervar -> NAME .)
    MINUS           reduce using rule 28 (pointervar -> NAME .)
    VALOF           reduce using rule 28 (pointervar -> NAME .)
    DIVIDE          reduce using rule 28 (pointervar -> NAME .)
    SEMICOLON       reduce using rule 28 (pointervar -> NAME .)
    RPAREN          reduce using rule 28 (pointervar -> NAME .)


state 29

    (8) declaration -> TYPE dlist1 SEMICOLON .

    TYPE            reduce using rule 8 (declaration -> TYPE dlist1 SEMICOLON .)
    VALOF           reduce using rule 8 (declaration -> TYPE dlist1 SEMICOLON .)
    NAME            reduce using rule 8 (declaration -> TYPE dlist1 SEMICOLON .)
    RBRACE          reduce using rule 8 (declaration -> TYPE dlist1 SEMICOLON .)


state 30

    (10) dlist1 -> NAME COMMA . dlist1
    (9) dlist1 -> . NAME
    (10) dlist1 -> . NAME COMMA dlist1
    (11) dlist1 -> . specialvar
    (12) dlist1 -> . specialvar COMMA dlist1
    (13) specialvar -> . VALOF specialvar
    (14) specialvar -> . VALOF NAME

    NAME            shift and go to state 18
    VALOF           shift and go to state 20

    dlist1                         shift and go to state 42
    specialvar                     shift and go to state 19

state 31

    (12) dlist1 -> specialvar COMMA . dlist1
    (9) dlist1 -> . NAME
    (10) dlist1 -> . NAME COMMA dlist1
    (11) dlist1 -> . specialvar
    (12) dlist1 -> . specialvar COMMA dlist1
    (13) specialvar -> . VALOF specialvar
    (14) specialvar -> . VALOF NAME

    NAME            shift and go to state 18
    VALOF           shift and go to state 20

    specialvar                     shift and go to state 19
    dlist1                         shift and go to state 43

state 32

    (13) specialvar -> VALOF specialvar .

    COMMA           reduce using rule 13 (specialvar -> VALOF specialvar .)
    SEMICOLON       reduce using rule 13 (specialvar -> VALOF specialvar .)


state 33

    (14) specialvar -> VALOF NAME .

    COMMA           reduce using rule 14 (specialvar -> VALOF NAME .)
    SEMICOLON       reduce using rule 14 (specialvar -> VALOF NAME .)


state 34

    (17) assignment_base -> NAME EQUALS expression .
    (18) expression -> expression . PLUS expression
    (19) expression -> expression . MINUS expression
    (20) expression -> expression . VALOF expression
    (21) expression -> expression . DIVIDE expression

    SEMICOLON       reduce using rule 17 (assignment_base -> NAME EQUALS expression .)
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    VALOF           shift and go to state 46
    DIVIDE          shift and go to state 47


state 35

    (22) expression -> MINUS . expression
    (18) expression -> . expression PLUS expression
    (19) expression -> . expression MINUS expression
    (20) expression -> . expression VALOF expression
    (21) expression -> . expression DIVIDE expression
    (22) expression -> . MINUS expression
    (23) expression -> . LPAREN expression RPAREN
    (24) expression -> . NUMBER
    (25) expression -> . pointervar
    (26) pointervar -> . VALOF pointervar
    (27) pointervar -> . ADDROF pointervar
    (28) pointervar -> . NAME

    MINUS           shift and go to state 35
    LPAREN          shift and go to state 36
    NUMBER          shift and go to state 37
    VALOF           shift and go to state 25
    ADDROF          shift and go to state 27
    NAME            shift and go to state 28

    expression                     shift and go to state 48
    pointervar                     shift and go to state 38

state 36

    (23) expression -> LPAREN . expression RPAREN
    (18) expression -> . expression PLUS expression
    (19) expression -> . expression MINUS expression
    (20) expression -> . expression VALOF expression
    (21) expression -> . expression DIVIDE expression
    (22) expression -> . MINUS expression
    (23) expression -> . LPAREN expression RPAREN
    (24) expression -> . NUMBER
    (25) expression -> . pointervar
    (26) pointervar -> . VALOF pointervar
    (27) pointervar -> . ADDROF pointervar
    (28) pointervar -> . NAME

    MINUS           shift and go to state 35
    LPAREN          shift and go to state 36
    NUMBER          shift and go to state 37
    VALOF           shift and go to state 25
    ADDROF          shift and go to state 27
    NAME            shift and go to state 28

    expression                     shift and go to state 49
    pointervar                     shift and go to state 38

state 37

    (24) expression -> NUMBER .

    PLUS            reduce using rule 24 (expression -> NUMBER .)
    MINUS           reduce using rule 24 (expression -> NUMBER .)
    VALOF           reduce using rule 24 (expression -> NUMBER .)
    DIVIDE          reduce using rule 24 (expression -> NUMBER .)
    SEMICOLON       reduce using rule 24 (expression -> NUMBER .)
    RPAREN          reduce using rule 24 (expression -> NUMBER .)


state 38

    (25) expression -> pointervar .

    PLUS            reduce using rule 25 (expression -> pointervar .)
    MINUS           reduce using rule 25 (expression -> pointervar .)
    VALOF           reduce using rule 25 (expression -> pointervar .)
    DIVIDE          reduce using rule 25 (expression -> pointervar .)
    SEMICOLON       reduce using rule 25 (expression -> pointervar .)
    RPAREN          reduce using rule 25 (expression -> pointervar .)


state 39

    (26) pointervar -> VALOF pointervar .

    EQUALS          reduce using rule 26 (pointervar -> VALOF pointervar .)
    PLUS            reduce using rule 26 (pointervar -> VALOF pointervar .)
    MINUS           reduce using rule 26 (pointervar -> VALOF pointervar .)
    VALOF           reduce using rule 26 (pointervar -> VALOF pointervar .)
    DIVIDE          reduce using rule 26 (pointervar -> VALOF pointervar .)
    SEMICOLON       reduce using rule 26 (pointervar -> VALOF pointervar .)
    RPAREN          reduce using rule 26 (pointervar -> VALOF pointervar .)


state 40

    (16) assignment_base -> VALOF pointervar EQUALS . expression
    (18) expression -> . expression PLUS expression
    (19) expression -> . expression MINUS expression
    (20) expression -> . expression VALOF expression
    (21) expression -> . expression DIVIDE expression
    (22) expression -> . MINUS expression
    (23) expression -> . LPAREN expression RPAREN
    (24) expression -> . NUMBER
    (25) expression -> . pointervar
    (26) pointervar -> . VALOF pointervar
    (27) pointervar -> . ADDROF pointervar
    (28) pointervar -> . NAME

    MINUS           shift and go to state 35
    LPAREN          shift and go to state 36
    NUMBER          shift and go to state 37
    VALOF           shift and go to state 25
    ADDROF          shift and go to state 27
    NAME            shift and go to state 28

    pointervar                     shift and go to state 38
    expression                     shift and go to state 50

state 41

    (27) pointervar -> ADDROF pointervar .

    EQUALS          reduce using rule 27 (pointervar -> ADDROF pointervar .)
    PLUS            reduce using rule 27 (pointervar -> ADDROF pointervar .)
    MINUS           reduce using rule 27 (pointervar -> ADDROF pointervar .)
    VALOF           reduce using rule 27 (pointervar -> ADDROF pointervar .)
    DIVIDE          reduce using rule 27 (pointervar -> ADDROF pointervar .)
    SEMICOLON       reduce using rule 27 (pointervar -> ADDROF pointervar .)
    RPAREN          reduce using rule 27 (pointervar -> ADDROF pointervar .)


state 42

    (10) dlist1 -> NAME COMMA dlist1 .

    SEMICOLON       reduce using rule 10 (dlist1 -> NAME COMMA dlist1 .)


state 43

    (12) dlist1 -> specialvar COMMA dlist1 .

    SEMICOLON       reduce using rule 12 (dlist1 -> specialvar COMMA dlist1 .)


state 44

    (18) expression -> expression PLUS . expression
    (18) expression -> . expression PLUS expression
    (19) expression -> . expression MINUS expression
    (20) expression -> . expression VALOF expression
    (21) expression -> . expression DIVIDE expression
    (22) expression -> . MINUS expression
    (23) expression -> . LPAREN expression RPAREN
    (24) expression -> . NUMBER
    (25) expression -> . pointervar
    (26) pointervar -> . VALOF pointervar
    (27) pointervar -> . ADDROF pointervar
    (28) pointervar -> . NAME

    MINUS           shift and go to state 35
    LPAREN          shift and go to state 36
    NUMBER          shift and go to state 37
    VALOF           shift and go to state 25
    ADDROF          shift and go to state 27
    NAME            shift and go to state 28

    expression                     shift and go to state 51
    pointervar                     shift and go to state 38

state 45

    (19) expression -> expression MINUS . expression
    (18) expression -> . expression PLUS expression
    (19) expression -> . expression MINUS expression
    (20) expression -> . expression VALOF expression
    (21) expression -> . expression DIVIDE expression
    (22) expression -> . MINUS expression
    (23) expression -> . LPAREN expression RPAREN
    (24) expression -> . NUMBER
    (25) expression -> . pointervar
    (26) pointervar -> . VALOF pointervar
    (27) pointervar -> . ADDROF pointervar
    (28) pointervar -> . NAME

    MINUS           shift and go to state 35
    LPAREN          shift and go to state 36
    NUMBER          shift and go to state 37
    VALOF           shift and go to state 25
    ADDROF          shift and go to state 27
    NAME            shift and go to state 28

    expression                     shift and go to state 52
    pointervar                     shift and go to state 38

state 46

    (20) expression -> expression VALOF . expression
    (18) expression -> . expression PLUS expression
    (19) expression -> . expression MINUS expression
    (20) expression -> . expression VALOF expression
    (21) expression -> . expression DIVIDE expression
    (22) expression -> . MINUS expression
    (23) expression -> . LPAREN expression RPAREN
    (24) expression -> . NUMBER
    (25) expression -> . pointervar
    (26) pointervar -> . VALOF pointervar
    (27) pointervar -> . ADDROF pointervar
    (28) pointervar -> . NAME

    MINUS           shift and go to state 35
    LPAREN          shift and go to state 36
    NUMBER          shift and go to state 37
    VALOF           shift and go to state 25
    ADDROF          shift and go to state 27
    NAME            shift and go to state 28

    expression                     shift and go to state 53
    pointervar                     shift and go to state 38

state 47

    (21) expression -> expression DIVIDE . expression
    (18) expression -> . expression PLUS expression
    (19) expression -> . expression MINUS expression
    (20) expression -> . expression VALOF expression
    (21) expression -> . expression DIVIDE expression
    (22) expression -> . MINUS expression
    (23) expression -> . LPAREN expression RPAREN
    (24) expression -> . NUMBER
    (25) expression -> . pointervar
    (26) pointervar -> . VALOF pointervar
    (27) pointervar -> . ADDROF pointervar
    (28) pointervar -> . NAME

    MINUS           shift and go to state 35
    LPAREN          shift and go to state 36
    NUMBER          shift and go to state 37
    VALOF           shift and go to state 25
    ADDROF          shift and go to state 27
    NAME            shift and go to state 28

    expression                     shift and go to state 54
    pointervar                     shift and go to state 38

state 48

    (22) expression -> MINUS expression .
    (18) expression -> expression . PLUS expression
    (19) expression -> expression . MINUS expression
    (20) expression -> expression . VALOF expression
    (21) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 22 (expression -> MINUS expression .)
    MINUS           reduce using rule 22 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 22 (expression -> MINUS expression .)
    SEMICOLON       reduce using rule 22 (expression -> MINUS expression .)
    RPAREN          reduce using rule 22 (expression -> MINUS expression .)
    VALOF           shift and go to state 46

  ! VALOF           [ reduce using rule 22 (expression -> MINUS expression .) ]
  ! PLUS            [ shift and go to state 44 ]
  ! MINUS           [ shift and go to state 45 ]
  ! DIVIDE          [ shift and go to state 47 ]


state 49

    (23) expression -> LPAREN expression . RPAREN
    (18) expression -> expression . PLUS expression
    (19) expression -> expression . MINUS expression
    (20) expression -> expression . VALOF expression
    (21) expression -> expression . DIVIDE expression

    RPAREN          shift and go to state 55
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    VALOF           shift and go to state 46
    DIVIDE          shift and go to state 47


state 50

    (16) assignment_base -> VALOF pointervar EQUALS expression .
    (18) expression -> expression . PLUS expression
    (19) expression -> expression . MINUS expression
    (20) expression -> expression . VALOF expression
    (21) expression -> expression . DIVIDE expression

    SEMICOLON       reduce using rule 16 (assignment_base -> VALOF pointervar EQUALS expression .)
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    VALOF           shift and go to state 46
    DIVIDE          shift and go to state 47


state 51

    (18) expression -> expression PLUS expression .
    (18) expression -> expression . PLUS expression
    (19) expression -> expression . MINUS expression
    (20) expression -> expression . VALOF expression
    (21) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 18 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 18 (expression -> expression PLUS expression .)
    SEMICOLON       reduce using rule 18 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 18 (expression -> expression PLUS expression .)
    VALOF           shift and go to state 46
    DIVIDE          shift and go to state 47

  ! VALOF           [ reduce using rule 18 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 18 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 44 ]
  ! MINUS           [ shift and go to state 45 ]


state 52

    (19) expression -> expression MINUS expression .
    (18) expression -> expression . PLUS expression
    (19) expression -> expression . MINUS expression
    (20) expression -> expression . VALOF expression
    (21) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 19 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 19 (expression -> expression MINUS expression .)
    SEMICOLON       reduce using rule 19 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 19 (expression -> expression MINUS expression .)
    VALOF           shift and go to state 46
    DIVIDE          shift and go to state 47

  ! VALOF           [ reduce using rule 19 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 19 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 44 ]
  ! MINUS           [ shift and go to state 45 ]


state 53

    (20) expression -> expression VALOF expression .
    (18) expression -> expression . PLUS expression
    (19) expression -> expression . MINUS expression
    (20) expression -> expression . VALOF expression
    (21) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 20 (expression -> expression VALOF expression .)
    MINUS           reduce using rule 20 (expression -> expression VALOF expression .)
    DIVIDE          reduce using rule 20 (expression -> expression VALOF expression .)
    SEMICOLON       reduce using rule 20 (expression -> expression VALOF expression .)
    RPAREN          reduce using rule 20 (expression -> expression VALOF expression .)
    VALOF           shift and go to state 46

  ! VALOF           [ reduce using rule 20 (expression -> expression VALOF expression .) ]
  ! PLUS            [ shift and go to state 44 ]
  ! MINUS           [ shift and go to state 45 ]
  ! DIVIDE          [ shift and go to state 47 ]


state 54

    (21) expression -> expression DIVIDE expression .
    (18) expression -> expression . PLUS expression
    (19) expression -> expression . MINUS expression
    (20) expression -> expression . VALOF expression
    (21) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 21 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 21 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 21 (expression -> expression DIVIDE expression .)
    SEMICOLON       reduce using rule 21 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 21 (expression -> expression DIVIDE expression .)
    VALOF           shift and go to state 46

  ! VALOF           [ reduce using rule 21 (expression -> expression DIVIDE expression .) ]
  ! PLUS            [ shift and go to state 44 ]
  ! MINUS           [ shift and go to state 45 ]
  ! DIVIDE          [ shift and go to state 47 ]


state 55

    (23) expression -> LPAREN expression RPAREN .

    PLUS            reduce using rule 23 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 23 (expression -> LPAREN expression RPAREN .)
    VALOF           reduce using rule 23 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 23 (expression -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 23 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 23 (expression -> LPAREN expression RPAREN .)

