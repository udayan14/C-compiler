Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    newline
    TIMES
    COMMENT

Grammar

Rule 0     S' -> program
Rule 1     program -> function
Rule 2     program -> function program
Rule 3     function -> TYPE NAME LPAREN RPAREN LBRACE fbody RBRACE
Rule 4     fbody -> statement
Rule 5     fbody -> statement fbody
Rule 6     statement -> assignment
Rule 7     statement -> declaration
Rule 8     declaration -> TYPE dlist1 SEMICOLON
Rule 9     dlist1 -> NAME
Rule 10    dlist1 -> NAME COMMA dlist1
Rule 11    dlist1 -> specialvar
Rule 12    dlist1 -> specialvar COMMA dlist1
Rule 13    specialvar -> VALOF specialvar
Rule 14    specialvar -> VALOF NAME
Rule 15    assignment -> assignment_base SEMICOLON
Rule 16    assignment_base -> VALOF pointervar EQUALS expression
Rule 17    assignment_base -> NAME EQUALS expression
Rule 18    expression -> expression PLUS expression
Rule 19    expression -> expression MINUS expression
Rule 20    expression -> expression VALOF expression
Rule 21    expression -> expression DIVIDE expression
Rule 22    expression -> MINUS expression
Rule 23    expression -> LPAREN expression RPAREN
Rule 24    expression -> NUMBER
Rule 25    expression -> pointervar
Rule 26    pointervar -> VALOF pointervar
Rule 27    pointervar -> ADDROF pointervar
Rule 28    pointervar -> NAME

Terminals, with rules where they appear

ADDROF               : 27
COMMA                : 10 12
COMMENT              : 
DIVIDE               : 21
EQUALS               : 16 17
LBRACE               : 3
LPAREN               : 3 23
MINUS                : 19 22
NAME                 : 3 9 10 14 17 28
NUMBER               : 24
PLUS                 : 18
RBRACE               : 3
RPAREN               : 3 23
SEMICOLON            : 8 15
TIMES                : 
TYPE                 : 3 8
VALOF                : 13 14 16 20 26
error                : 
newline              : 

Nonterminals, with rules where they appear

assignment           : 6
assignment_base      : 15
declaration          : 7
dlist1               : 8 10 12
expression           : 16 17 18 18 19 19 20 20 21 21 22 23
fbody                : 3 5
function             : 1 2
pointervar           : 16 25 26 27
program              : 2 0
specialvar           : 11 12 13
statement            : 4 5

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . function
    (2) program -> . function program
    (3) function -> . TYPE NAME LPAREN RPAREN LBRACE fbody RBRACE

    TYPE            shift and go to state 2

    program                        shift and go to state 1
    function                       shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (3) function -> TYPE . NAME LPAREN RPAREN LBRACE fbody RBRACE

    NAME            shift and go to state 4


state 3

    (1) program -> function .
    (2) program -> function . program
    (1) program -> . function
    (2) program -> . function program
    (3) function -> . TYPE NAME LPAREN RPAREN LBRACE fbody RBRACE

    $end            reduce using rule 1 (program -> function .)
    TYPE            shift and go to state 2

    function                       shift and go to state 3
    program                        shift and go to state 5

state 4

    (3) function -> TYPE NAME . LPAREN RPAREN LBRACE fbody RBRACE

    LPAREN          shift and go to state 6


state 5

    (2) program -> function program .

    $end            reduce using rule 2 (program -> function program .)


state 6

    (3) function -> TYPE NAME LPAREN . RPAREN LBRACE fbody RBRACE

    RPAREN          shift and go to state 7


state 7

    (3) function -> TYPE NAME LPAREN RPAREN . LBRACE fbody RBRACE

    LBRACE          shift and go to state 8


state 8

    (3) function -> TYPE NAME LPAREN RPAREN LBRACE . fbody RBRACE
    (4) fbody -> . statement
    (5) fbody -> . statement fbody
    (6) statement -> . assignment
    (7) statement -> . declaration
    (15) assignment -> . assignment_base SEMICOLON
    (8) declaration -> . TYPE dlist1 SEMICOLON
    (16) assignment_base -> . VALOF pointervar EQUALS expression
    (17) assignment_base -> . NAME EQUALS expression

    TYPE            shift and go to state 14
    VALOF           shift and go to state 15
    NAME            shift and go to state 13

    fbody                          shift and go to state 9
    declaration                    shift and go to state 10
    statement                      shift and go to state 11
    assignment                     shift and go to state 16
    assignment_base                shift and go to state 12

state 9

    (3) function -> TYPE NAME LPAREN RPAREN LBRACE fbody . RBRACE

    RBRACE          shift and go to state 17


state 10

    (7) statement -> declaration .

    TYPE            reduce using rule 7 (statement -> declaration .)
    VALOF           reduce using rule 7 (statement -> declaration .)
    NAME            reduce using rule 7 (statement -> declaration .)
    RBRACE          reduce using rule 7 (statement -> declaration .)


state 11

    (4) fbody -> statement .
    (5) fbody -> statement . fbody
    (4) fbody -> . statement
    (5) fbody -> . statement fbody
    (6) statement -> . assignment
    (7) statement -> . declaration
    (15) assignment -> . assignment_base SEMICOLON
    (8) declaration -> . TYPE dlist1 SEMICOLON
    (16) assignment_base -> . VALOF pointervar EQUALS expression
    (17) assignment_base -> . NAME EQUALS expression

    RBRACE          reduce using rule 4 (fbody -> statement .)
    TYPE            shift and go to state 14
    VALOF           shift and go to state 15
    NAME            shift and go to state 13

    fbody                          shift and go to state 18
    declaration                    shift and go to state 10
    statement                      shift and go to state 11
    assignment                     shift and go to state 16
    assignment_base                shift and go to state 12

state 12

    (15) assignment -> assignment_base . SEMICOLON

    SEMICOLON       shift and go to state 19


state 13

    (17) assignment_base -> NAME . EQUALS expression

    EQUALS          shift and go to state 20


state 14

    (8) declaration -> TYPE . dlist1 SEMICOLON
    (9) dlist1 -> . NAME
    (10) dlist1 -> . NAME COMMA dlist1
    (11) dlist1 -> . specialvar
    (12) dlist1 -> . specialvar COMMA dlist1
    (13) specialvar -> . VALOF specialvar
    (14) specialvar -> . VALOF NAME

    NAME            shift and go to state 22
    VALOF           shift and go to state 23

    dlist1                         shift and go to state 21
    specialvar                     shift and go to state 24

state 15

    (16) assignment_base -> VALOF . pointervar EQUALS expression
    (26) pointervar -> . VALOF pointervar
    (27) pointervar -> . ADDROF pointervar
    (28) pointervar -> . NAME

    VALOF           shift and go to state 28
    ADDROF          shift and go to state 25
    NAME            shift and go to state 26

    pointervar                     shift and go to state 27

state 16

    (6) statement -> assignment .

    TYPE            reduce using rule 6 (statement -> assignment .)
    VALOF           reduce using rule 6 (statement -> assignment .)
    NAME            reduce using rule 6 (statement -> assignment .)
    RBRACE          reduce using rule 6 (statement -> assignment .)


state 17

    (3) function -> TYPE NAME LPAREN RPAREN LBRACE fbody RBRACE .

    TYPE            reduce using rule 3 (function -> TYPE NAME LPAREN RPAREN LBRACE fbody RBRACE .)
    $end            reduce using rule 3 (function -> TYPE NAME LPAREN RPAREN LBRACE fbody RBRACE .)


state 18

    (5) fbody -> statement fbody .

    RBRACE          reduce using rule 5 (fbody -> statement fbody .)


state 19

    (15) assignment -> assignment_base SEMICOLON .

    TYPE            reduce using rule 15 (assignment -> assignment_base SEMICOLON .)
    VALOF           reduce using rule 15 (assignment -> assignment_base SEMICOLON .)
    NAME            reduce using rule 15 (assignment -> assignment_base SEMICOLON .)
    RBRACE          reduce using rule 15 (assignment -> assignment_base SEMICOLON .)


state 20

    (17) assignment_base -> NAME EQUALS . expression
    (18) expression -> . expression PLUS expression
    (19) expression -> . expression MINUS expression
    (20) expression -> . expression VALOF expression
    (21) expression -> . expression DIVIDE expression
    (22) expression -> . MINUS expression
    (23) expression -> . LPAREN expression RPAREN
    (24) expression -> . NUMBER
    (25) expression -> . pointervar
    (26) pointervar -> . VALOF pointervar
    (27) pointervar -> . ADDROF pointervar
    (28) pointervar -> . NAME

    MINUS           shift and go to state 31
    LPAREN          shift and go to state 29
    NUMBER          shift and go to state 33
    VALOF           shift and go to state 28
    ADDROF          shift and go to state 25
    NAME            shift and go to state 26

    pointervar                     shift and go to state 30
    expression                     shift and go to state 32

state 21

    (8) declaration -> TYPE dlist1 . SEMICOLON

    SEMICOLON       shift and go to state 34


state 22

    (9) dlist1 -> NAME .
    (10) dlist1 -> NAME . COMMA dlist1

    SEMICOLON       reduce using rule 9 (dlist1 -> NAME .)
    COMMA           shift and go to state 35


state 23

    (13) specialvar -> VALOF . specialvar
    (14) specialvar -> VALOF . NAME
    (13) specialvar -> . VALOF specialvar
    (14) specialvar -> . VALOF NAME

    NAME            shift and go to state 36
    VALOF           shift and go to state 23

    specialvar                     shift and go to state 37

state 24

    (11) dlist1 -> specialvar .
    (12) dlist1 -> specialvar . COMMA dlist1

    SEMICOLON       reduce using rule 11 (dlist1 -> specialvar .)
    COMMA           shift and go to state 38


state 25

    (27) pointervar -> ADDROF . pointervar
    (26) pointervar -> . VALOF pointervar
    (27) pointervar -> . ADDROF pointervar
    (28) pointervar -> . NAME

    VALOF           shift and go to state 28
    ADDROF          shift and go to state 25
    NAME            shift and go to state 26

    pointervar                     shift and go to state 39

state 26

    (28) pointervar -> NAME .

    PLUS            reduce using rule 28 (pointervar -> NAME .)
    MINUS           reduce using rule 28 (pointervar -> NAME .)
    VALOF           reduce using rule 28 (pointervar -> NAME .)
    DIVIDE          reduce using rule 28 (pointervar -> NAME .)
    SEMICOLON       reduce using rule 28 (pointervar -> NAME .)
    EQUALS          reduce using rule 28 (pointervar -> NAME .)
    RPAREN          reduce using rule 28 (pointervar -> NAME .)


state 27

    (16) assignment_base -> VALOF pointervar . EQUALS expression

    EQUALS          shift and go to state 40


state 28

    (26) pointervar -> VALOF . pointervar
    (26) pointervar -> . VALOF pointervar
    (27) pointervar -> . ADDROF pointervar
    (28) pointervar -> . NAME

    VALOF           shift and go to state 28
    ADDROF          shift and go to state 25
    NAME            shift and go to state 26

    pointervar                     shift and go to state 41

state 29

    (23) expression -> LPAREN . expression RPAREN
    (18) expression -> . expression PLUS expression
    (19) expression -> . expression MINUS expression
    (20) expression -> . expression VALOF expression
    (21) expression -> . expression DIVIDE expression
    (22) expression -> . MINUS expression
    (23) expression -> . LPAREN expression RPAREN
    (24) expression -> . NUMBER
    (25) expression -> . pointervar
    (26) pointervar -> . VALOF pointervar
    (27) pointervar -> . ADDROF pointervar
    (28) pointervar -> . NAME

    MINUS           shift and go to state 31
    LPAREN          shift and go to state 29
    NUMBER          shift and go to state 33
    VALOF           shift and go to state 28
    ADDROF          shift and go to state 25
    NAME            shift and go to state 26

    pointervar                     shift and go to state 30
    expression                     shift and go to state 42

state 30

    (25) expression -> pointervar .

    PLUS            reduce using rule 25 (expression -> pointervar .)
    MINUS           reduce using rule 25 (expression -> pointervar .)
    VALOF           reduce using rule 25 (expression -> pointervar .)
    DIVIDE          reduce using rule 25 (expression -> pointervar .)
    SEMICOLON       reduce using rule 25 (expression -> pointervar .)
    RPAREN          reduce using rule 25 (expression -> pointervar .)


state 31

    (22) expression -> MINUS . expression
    (18) expression -> . expression PLUS expression
    (19) expression -> . expression MINUS expression
    (20) expression -> . expression VALOF expression
    (21) expression -> . expression DIVIDE expression
    (22) expression -> . MINUS expression
    (23) expression -> . LPAREN expression RPAREN
    (24) expression -> . NUMBER
    (25) expression -> . pointervar
    (26) pointervar -> . VALOF pointervar
    (27) pointervar -> . ADDROF pointervar
    (28) pointervar -> . NAME

    MINUS           shift and go to state 31
    LPAREN          shift and go to state 29
    NUMBER          shift and go to state 33
    VALOF           shift and go to state 28
    ADDROF          shift and go to state 25
    NAME            shift and go to state 26

    pointervar                     shift and go to state 30
    expression                     shift and go to state 43

state 32

    (17) assignment_base -> NAME EQUALS expression .
    (18) expression -> expression . PLUS expression
    (19) expression -> expression . MINUS expression
    (20) expression -> expression . VALOF expression
    (21) expression -> expression . DIVIDE expression

    SEMICOLON       reduce using rule 17 (assignment_base -> NAME EQUALS expression .)
    PLUS            shift and go to state 47
    MINUS           shift and go to state 44
    VALOF           shift and go to state 46
    DIVIDE          shift and go to state 45


state 33

    (24) expression -> NUMBER .

    PLUS            reduce using rule 24 (expression -> NUMBER .)
    MINUS           reduce using rule 24 (expression -> NUMBER .)
    VALOF           reduce using rule 24 (expression -> NUMBER .)
    DIVIDE          reduce using rule 24 (expression -> NUMBER .)
    SEMICOLON       reduce using rule 24 (expression -> NUMBER .)
    RPAREN          reduce using rule 24 (expression -> NUMBER .)


state 34

    (8) declaration -> TYPE dlist1 SEMICOLON .

    TYPE            reduce using rule 8 (declaration -> TYPE dlist1 SEMICOLON .)
    VALOF           reduce using rule 8 (declaration -> TYPE dlist1 SEMICOLON .)
    NAME            reduce using rule 8 (declaration -> TYPE dlist1 SEMICOLON .)
    RBRACE          reduce using rule 8 (declaration -> TYPE dlist1 SEMICOLON .)


state 35

    (10) dlist1 -> NAME COMMA . dlist1
    (9) dlist1 -> . NAME
    (10) dlist1 -> . NAME COMMA dlist1
    (11) dlist1 -> . specialvar
    (12) dlist1 -> . specialvar COMMA dlist1
    (13) specialvar -> . VALOF specialvar
    (14) specialvar -> . VALOF NAME

    NAME            shift and go to state 22
    VALOF           shift and go to state 23

    dlist1                         shift and go to state 48
    specialvar                     shift and go to state 24

state 36

    (14) specialvar -> VALOF NAME .

    COMMA           reduce using rule 14 (specialvar -> VALOF NAME .)
    SEMICOLON       reduce using rule 14 (specialvar -> VALOF NAME .)


state 37

    (13) specialvar -> VALOF specialvar .

    COMMA           reduce using rule 13 (specialvar -> VALOF specialvar .)
    SEMICOLON       reduce using rule 13 (specialvar -> VALOF specialvar .)


state 38

    (12) dlist1 -> specialvar COMMA . dlist1
    (9) dlist1 -> . NAME
    (10) dlist1 -> . NAME COMMA dlist1
    (11) dlist1 -> . specialvar
    (12) dlist1 -> . specialvar COMMA dlist1
    (13) specialvar -> . VALOF specialvar
    (14) specialvar -> . VALOF NAME

    NAME            shift and go to state 22
    VALOF           shift and go to state 23

    dlist1                         shift and go to state 49
    specialvar                     shift and go to state 24

state 39

    (27) pointervar -> ADDROF pointervar .

    PLUS            reduce using rule 27 (pointervar -> ADDROF pointervar .)
    MINUS           reduce using rule 27 (pointervar -> ADDROF pointervar .)
    VALOF           reduce using rule 27 (pointervar -> ADDROF pointervar .)
    DIVIDE          reduce using rule 27 (pointervar -> ADDROF pointervar .)
    SEMICOLON       reduce using rule 27 (pointervar -> ADDROF pointervar .)
    EQUALS          reduce using rule 27 (pointervar -> ADDROF pointervar .)
    RPAREN          reduce using rule 27 (pointervar -> ADDROF pointervar .)


state 40

    (16) assignment_base -> VALOF pointervar EQUALS . expression
    (18) expression -> . expression PLUS expression
    (19) expression -> . expression MINUS expression
    (20) expression -> . expression VALOF expression
    (21) expression -> . expression DIVIDE expression
    (22) expression -> . MINUS expression
    (23) expression -> . LPAREN expression RPAREN
    (24) expression -> . NUMBER
    (25) expression -> . pointervar
    (26) pointervar -> . VALOF pointervar
    (27) pointervar -> . ADDROF pointervar
    (28) pointervar -> . NAME

    MINUS           shift and go to state 31
    LPAREN          shift and go to state 29
    NUMBER          shift and go to state 33
    VALOF           shift and go to state 28
    ADDROF          shift and go to state 25
    NAME            shift and go to state 26

    pointervar                     shift and go to state 30
    expression                     shift and go to state 50

state 41

    (26) pointervar -> VALOF pointervar .

    PLUS            reduce using rule 26 (pointervar -> VALOF pointervar .)
    MINUS           reduce using rule 26 (pointervar -> VALOF pointervar .)
    VALOF           reduce using rule 26 (pointervar -> VALOF pointervar .)
    DIVIDE          reduce using rule 26 (pointervar -> VALOF pointervar .)
    SEMICOLON       reduce using rule 26 (pointervar -> VALOF pointervar .)
    EQUALS          reduce using rule 26 (pointervar -> VALOF pointervar .)
    RPAREN          reduce using rule 26 (pointervar -> VALOF pointervar .)


state 42

    (23) expression -> LPAREN expression . RPAREN
    (18) expression -> expression . PLUS expression
    (19) expression -> expression . MINUS expression
    (20) expression -> expression . VALOF expression
    (21) expression -> expression . DIVIDE expression

    RPAREN          shift and go to state 51
    PLUS            shift and go to state 47
    MINUS           shift and go to state 44
    VALOF           shift and go to state 46
    DIVIDE          shift and go to state 45


state 43

    (22) expression -> MINUS expression .
    (18) expression -> expression . PLUS expression
    (19) expression -> expression . MINUS expression
    (20) expression -> expression . VALOF expression
    (21) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 22 (expression -> MINUS expression .)
    MINUS           reduce using rule 22 (expression -> MINUS expression .)
    VALOF           reduce using rule 22 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 22 (expression -> MINUS expression .)
    SEMICOLON       reduce using rule 22 (expression -> MINUS expression .)
    RPAREN          reduce using rule 22 (expression -> MINUS expression .)

  ! PLUS            [ shift and go to state 47 ]
  ! MINUS           [ shift and go to state 44 ]
  ! VALOF           [ shift and go to state 46 ]
  ! DIVIDE          [ shift and go to state 45 ]


state 44

    (19) expression -> expression MINUS . expression
    (18) expression -> . expression PLUS expression
    (19) expression -> . expression MINUS expression
    (20) expression -> . expression VALOF expression
    (21) expression -> . expression DIVIDE expression
    (22) expression -> . MINUS expression
    (23) expression -> . LPAREN expression RPAREN
    (24) expression -> . NUMBER
    (25) expression -> . pointervar
    (26) pointervar -> . VALOF pointervar
    (27) pointervar -> . ADDROF pointervar
    (28) pointervar -> . NAME

    MINUS           shift and go to state 31
    LPAREN          shift and go to state 29
    NUMBER          shift and go to state 33
    VALOF           shift and go to state 28
    ADDROF          shift and go to state 25
    NAME            shift and go to state 26

    pointervar                     shift and go to state 30
    expression                     shift and go to state 52

state 45

    (21) expression -> expression DIVIDE . expression
    (18) expression -> . expression PLUS expression
    (19) expression -> . expression MINUS expression
    (20) expression -> . expression VALOF expression
    (21) expression -> . expression DIVIDE expression
    (22) expression -> . MINUS expression
    (23) expression -> . LPAREN expression RPAREN
    (24) expression -> . NUMBER
    (25) expression -> . pointervar
    (26) pointervar -> . VALOF pointervar
    (27) pointervar -> . ADDROF pointervar
    (28) pointervar -> . NAME

    MINUS           shift and go to state 31
    LPAREN          shift and go to state 29
    NUMBER          shift and go to state 33
    VALOF           shift and go to state 28
    ADDROF          shift and go to state 25
    NAME            shift and go to state 26

    pointervar                     shift and go to state 30
    expression                     shift and go to state 53

state 46

    (20) expression -> expression VALOF . expression
    (18) expression -> . expression PLUS expression
    (19) expression -> . expression MINUS expression
    (20) expression -> . expression VALOF expression
    (21) expression -> . expression DIVIDE expression
    (22) expression -> . MINUS expression
    (23) expression -> . LPAREN expression RPAREN
    (24) expression -> . NUMBER
    (25) expression -> . pointervar
    (26) pointervar -> . VALOF pointervar
    (27) pointervar -> . ADDROF pointervar
    (28) pointervar -> . NAME

    MINUS           shift and go to state 31
    LPAREN          shift and go to state 29
    NUMBER          shift and go to state 33
    VALOF           shift and go to state 28
    ADDROF          shift and go to state 25
    NAME            shift and go to state 26

    pointervar                     shift and go to state 30
    expression                     shift and go to state 54

state 47

    (18) expression -> expression PLUS . expression
    (18) expression -> . expression PLUS expression
    (19) expression -> . expression MINUS expression
    (20) expression -> . expression VALOF expression
    (21) expression -> . expression DIVIDE expression
    (22) expression -> . MINUS expression
    (23) expression -> . LPAREN expression RPAREN
    (24) expression -> . NUMBER
    (25) expression -> . pointervar
    (26) pointervar -> . VALOF pointervar
    (27) pointervar -> . ADDROF pointervar
    (28) pointervar -> . NAME

    MINUS           shift and go to state 31
    LPAREN          shift and go to state 29
    NUMBER          shift and go to state 33
    VALOF           shift and go to state 28
    ADDROF          shift and go to state 25
    NAME            shift and go to state 26

    pointervar                     shift and go to state 30
    expression                     shift and go to state 55

state 48

    (10) dlist1 -> NAME COMMA dlist1 .

    SEMICOLON       reduce using rule 10 (dlist1 -> NAME COMMA dlist1 .)


state 49

    (12) dlist1 -> specialvar COMMA dlist1 .

    SEMICOLON       reduce using rule 12 (dlist1 -> specialvar COMMA dlist1 .)


state 50

    (16) assignment_base -> VALOF pointervar EQUALS expression .
    (18) expression -> expression . PLUS expression
    (19) expression -> expression . MINUS expression
    (20) expression -> expression . VALOF expression
    (21) expression -> expression . DIVIDE expression

    SEMICOLON       reduce using rule 16 (assignment_base -> VALOF pointervar EQUALS expression .)
    PLUS            shift and go to state 47
    MINUS           shift and go to state 44
    VALOF           shift and go to state 46
    DIVIDE          shift and go to state 45


state 51

    (23) expression -> LPAREN expression RPAREN .

    PLUS            reduce using rule 23 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 23 (expression -> LPAREN expression RPAREN .)
    VALOF           reduce using rule 23 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 23 (expression -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 23 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 23 (expression -> LPAREN expression RPAREN .)


state 52

    (19) expression -> expression MINUS expression .
    (18) expression -> expression . PLUS expression
    (19) expression -> expression . MINUS expression
    (20) expression -> expression . VALOF expression
    (21) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 19 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 19 (expression -> expression MINUS expression .)
    SEMICOLON       reduce using rule 19 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 19 (expression -> expression MINUS expression .)
    VALOF           shift and go to state 46
    DIVIDE          shift and go to state 45

  ! VALOF           [ reduce using rule 19 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 19 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 47 ]
  ! MINUS           [ shift and go to state 44 ]


state 53

    (21) expression -> expression DIVIDE expression .
    (18) expression -> expression . PLUS expression
    (19) expression -> expression . MINUS expression
    (20) expression -> expression . VALOF expression
    (21) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 21 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 21 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 21 (expression -> expression DIVIDE expression .)
    SEMICOLON       reduce using rule 21 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 21 (expression -> expression DIVIDE expression .)
    VALOF           shift and go to state 46

  ! VALOF           [ reduce using rule 21 (expression -> expression DIVIDE expression .) ]
  ! PLUS            [ shift and go to state 47 ]
  ! MINUS           [ shift and go to state 44 ]
  ! DIVIDE          [ shift and go to state 45 ]


state 54

    (20) expression -> expression VALOF expression .
    (18) expression -> expression . PLUS expression
    (19) expression -> expression . MINUS expression
    (20) expression -> expression . VALOF expression
    (21) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 20 (expression -> expression VALOF expression .)
    MINUS           reduce using rule 20 (expression -> expression VALOF expression .)
    DIVIDE          reduce using rule 20 (expression -> expression VALOF expression .)
    SEMICOLON       reduce using rule 20 (expression -> expression VALOF expression .)
    RPAREN          reduce using rule 20 (expression -> expression VALOF expression .)
    VALOF           shift and go to state 46

  ! VALOF           [ reduce using rule 20 (expression -> expression VALOF expression .) ]
  ! PLUS            [ shift and go to state 47 ]
  ! MINUS           [ shift and go to state 44 ]
  ! DIVIDE          [ shift and go to state 45 ]


state 55

    (18) expression -> expression PLUS expression .
    (18) expression -> expression . PLUS expression
    (19) expression -> expression . MINUS expression
    (20) expression -> expression . VALOF expression
    (21) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 18 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 18 (expression -> expression PLUS expression .)
    SEMICOLON       reduce using rule 18 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 18 (expression -> expression PLUS expression .)
    VALOF           shift and go to state 46
    DIVIDE          shift and go to state 45

  ! VALOF           [ reduce using rule 18 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 18 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 47 ]
  ! MINUS           [ shift and go to state 44 ]

